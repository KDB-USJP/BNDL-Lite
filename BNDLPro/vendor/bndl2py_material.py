# (full file)
from __future__ import annotations
import re, sys, os, json, math
from dataclasses import dataclass, field
from typing import List, Dict, Tuple, Optional, Any

# Import tree type utilities
try:
    from .bndl_common import TreeType as BNDLTreeType
    TreeType = BNDLTreeType  # Alias for compatibility
except ImportError:
    # Fallback for standalone usage
    class TreeType:
        GEOMETRY = "GEOMETRY"
        MATERIAL = "MATERIAL"
        COMPOSITOR = "COMPOSITOR"

def parse_tree_type_header(bndl_content: str) -> Optional[str]:
    """Parse the Tree_Type header from BNDL content."""
    lines = bndl_content.split('\n')
    for line in lines[:10]:  # Check first 10 lines
        line = line.strip()
        if line.startswith('Tree_Type:'):
            type_str = line.split(':', 1)[1].strip()
            return type_str
    return None  # No header found

# --------------------------
# AST
# --------------------------
@dataclass
class NodeRef:
    ui_type: str
    label: str
    inst: str
    bl_idname: Optional[str] = None

@dataclass
class CreateStmt:
    node: NodeRef
    variant: str

@dataclass
class DeclareStmt:
    side: str  # 'inputs' or 'outputs'
    node: NodeRef
    ports: List[str]

@dataclass
class SetEntry:
    key: str
    val: Any

@dataclass
class SetStmt:
    node: NodeRef
    entries: List[SetEntry]

@dataclass
class ConnectStmt:
    dotted: bool
    to_node: NodeRef
    to_port: str
    from_field: Optional[str] = None
    from_node: Optional[NodeRef] = None
    from_port: Optional[str] = None

@dataclass
class PairZoneStmt:
    kind: str
    left: NodeRef
    right: NodeRef

@dataclass
class GroupDef:
    name: str
    steps: List[Any]

@dataclass
class BNDLDoc:
    version: str
    groups: List[GroupDef]
    top_steps: List[Any]


# --------------------------
# Helpers
# --------------------------
def _strip_num(s: str) -> str:
    return re.sub(r'^\s*\(\d+\)\s*', '', s).rstrip()

def _split_ports(s: str) -> List[str]:
    # ports are tokens separated by commas on one line:  ‚óã A , ‚óã B  or  ‚¶ø A , ‚¶ø B
    out = []
    for part in s.split(','):
        part = part.strip()
        part = re.sub(r'^[‚óã‚¶ø]\s*', '', part)
        if part:
            out.append(part)
    return out

# --------------------------
# Parser
# --------------------------

def _parse_node(s: str) -> NodeRef:
    t = s.strip()
    m = re.search(r'\[\s*(.+?)\s*\]', t)
    if not m:
        return NodeRef(ui_type=t, label="", inst="")
    bracket = m.group(1)
    parts = [p.strip() for p in bracket.split('|')]

    # UI chunk with normalization: strip any inline "#<n>" from the label inside brackets.
    ui_chunk = (parts[0] if parts else "").strip()
    ui_chunk = re.sub(r'\s+#\s*\d+\s*', ' ', ui_chunk)
    ui_type = re.sub(r'\s{2,}', ' ', ui_chunk).strip()

    # Friendly ~label~ (optional)
    m_lbl = re.search(r'~\s*(.*?)\s*~', t)
    label = (m_lbl.group(1).strip() if m_lbl else "")

    # Instance number anywhere after a # token
    m_id = re.search(r'#\s*(\d+)', t)
    inst = m_id.group(1) if m_id else ""

    # Optional ; type=BlIdName
    m_tid = re.search(r';\s*type\s*=\s*([A-Za-z_0-9]+)', t)
    blid = m_tid.group(1) if m_tid else None

    # --- IMPORTANT NORMALIZATION ---
    # Some exports write "Simulation" in the UI chunk on Create, but ports/links use
    # "Simulation Input" / "Simulation Output". Normalize ui_type based on bl_idname.
    if blid:
        low = blid.lower()
        if "simulationinput" in low:
            ui_type = "Simulation Input"
        elif "simulationoutput" in low:
            ui_type = "Simulation Output"

    return NodeRef(ui_type=ui_type, label=label, inst=inst, bl_idname=blid)

def _parse_steps(lines: List[str], ctx: str) -> List[Any]:
    """
    Tolerant BNDL v1.2 step parser.
    Captures: Create / Declare / Set / Connect / Rename (node) / rename_input (Case N) lines.
    Ignores section headers (# === ‚Ä¶ ===), blank lines, and comments starting with '#' or ';'.
    Returns: list[dict] steps suitable for the IR used by codegen.
    """
    import re

    steps = []
    i = 0
    N = len(lines)

    # helpers ---------------------------------------------------------
    def _tok_node(m_ui, m_inst, m_bl=None, m_label=None):
        return {
            "ui_type": (m_ui or "").strip(),
            "inst": (m_inst or "").strip(),
            "bl_idname": (m_bl or "").strip(),
            "label": (m_label or "").strip(),
        }

    def _is_comment_or_header(s):
        ss = s.strip()
        if not ss:
            return True
        if ss.startswith("#"):
            return True
        if ss.startswith(";"):
            return True
        return False

    # regexes ---------------------------------------------------------
    # Create  ShaderNodeOutputMaterial  "Material Output#1"
    RX_CREATE = re.compile(
        r"""^Create\s+(?P<bl>[A-Za-z0-9_\.]+)\s+"(?P<label>.+?)#(?P<inst>\d+)"\s*$""",
        re.I,
    )
    # Declare [ Index Switch #1 ] inputs: (Index, Data, Case 1, Case 2, ...)
    # OR Declare Inputs [Group Input #1] : Geometry, Value (export format)
    RX_DECLARE = re.compile(
        r"""^Declare\s*(?:(?P<side>inputs|outputs)\s*\[\s*(?P<ui>.+?)\s*#(?P<inst>\d+)\s*\]\s*:\s*(?P<ports>.*?)|\[\s*(?P<ui2>.+?)\s*#(?P<inst2>\d+)\s*\]\s*(?P<side2>inputs|outputs)\s*:\s*[\(\s]*(?P<ports2>.*?)[\)\s]*)\s*$""",
        re.I,
    )
    # Set  [ Material Output#1 ]
    RX_SET_HDR = re.compile(
        r"""^Set\s*\[\s*(?P<ui>.+?)\s*#(?P<inst>\d+)\s*\]\s*$""",
        re.I,
    )
    # "Displacement" to <0, 0, 0>
    RX_SET_KV = re.compile(
        r"""^\s*"(?P<key>.+?)"\s*to\s*(?P<val>.+?)\s*$""",
        re.I,
    )

    # SetUser [ Node #1 ]:
    RX_SETUSER_HDR = re.compile(
        r"""^SetUser\s*\[\s*(?P<ui>.+?)\s*#(?P<inst>\d+)\s*\]\s*:\s*$""",
        re.I,
    )

    # Connect  "Principled BSDF#2"  "BSDF"  to  "Material Output#1"  "Surface"
    RX_CONNECT = re.compile(
        r"""^Connect\s*"(?P<fui>.+?)#(?P<finst>\d+)"\s*"(?P<fport>.+?)"\s*to\s*"(?P<tui>.+?)#(?P<tinst>\d+)"\s*"(?P<tport>.+?)"\s*$""",
        re.I,
    )

    # Rename  [ Node #1 ] to ~ New Label ~
    RX_RENAME_NODE = re.compile(
        r"""^Rename\s*\[\s*(?P<ui>.+?)\s*#(?P<inst>\d+)\s*\]\s*to\s*~\s*(?P<label>.*?)\s*~\s*$""",
        re.I,
    )
    # Rename input sockets (existing format): Rename Input [ Node #1 ] "Case 3" -> "Front"
    RX_RENAME_INPUT = re.compile(
        r"""^Rename\s+Input\s*\[\s*(?P<ui>.+?)\s*#(?P<inst>\d+)\s*\]\s*"(?P<old>.+?)"\s*->\s*"(?P<new>.+?)"\s*$""",
        re.I,
    )

    # main loop -------------------------------------------------------
    while i < N:
        L = lines[i].rstrip("\n")
        if _is_comment_or_header(L):
            i += 1
            continue

        # Try modern v1.4 format parser first (handles Create/Declare/Connect with square brackets AND quoted format)
        stmt = _parse_line(L)
        if stmt is not None:
            # Convert AST objects to dict format for IR
            if isinstance(stmt, CreateStmt):
                steps.append({
                    "kind": "create",
                    "node": _tok_node(stmt.node.ui_type, stmt.node.inst, stmt.node.bl_idname, stmt.node.label),
                    "variant": stmt.variant,
                })
                i += 1
                continue
            elif isinstance(stmt, DeclareStmt):
                steps.append({
                    "kind": "declare",
                    "side": stmt.side,
                    "node": _tok_node(stmt.node.ui_type, stmt.node.inst, stmt.node.bl_idname, stmt.node.label),
                    "ports": stmt.ports,
                })
                i += 1
                continue
            elif isinstance(stmt, ConnectStmt):
                steps.append({
                    "kind": "connect",
                    "dotted": stmt.dotted,
                    "from": _tok_node(stmt.from_node.ui_type, stmt.from_node.inst, stmt.from_node.bl_idname, stmt.from_node.label) if stmt.from_node else None,
                    "from_port": stmt.from_port,
                    "to": _tok_node(stmt.to_node.ui_type, stmt.to_node.inst, stmt.to_node.bl_idname, stmt.to_node.label),
                    "to_port": stmt.to_port,
                    "from_field": stmt.from_field,
                })
                i += 1
                continue
            elif isinstance(stmt, PairZoneStmt):
                steps.append({
                    "kind": "pairzone",
                    "zone": stmt.kind,
                    "left": _tok_node(stmt.left.ui_type, stmt.left.inst, stmt.left.bl_idname, stmt.left.label),
                    "right": _tok_node(stmt.right.ui_type, stmt.right.inst, stmt.right.bl_idname, stmt.right.label),
                })
                i += 1
                continue
            elif isinstance(stmt, dict):
                # Already a dict (e.g., Parent command) - append as-is
                steps.append(stmt)
                i += 1
                continue

        # Fall back to old v1.2/v1.3 regex parsers for compatibility
        # CREATE
        m = RX_CREATE.match(L)
        if m:
            # Extract ui_type from label (display name before #inst)
            label_full = m.group("label")
            ui_type = label_full.rsplit("#", 1)[0] if "#" in label_full else label_full
            steps.append(
                {
                    "kind": "create",
                    "node": _tok_node(ui_type, m.group("inst"), m.group("bl"), label_full),
                    "variant": "‚Äî",
                }
            )

            i += 1
            continue

        # DECLARE
        m = RX_DECLARE.match(L)
        if m:
            # Handle both export format (side, ui, inst, ports) and legacy format (ui2, inst2, side2, ports2)
            if m.group('side') and m.group('ui') and m.group('inst'):
                # Export format: "Declare Inputs [Group Input #1] : Geometry, Value"
                side = m.group('side').lower()
                ui = m.group('ui')
                inst = m.group('inst')
                ports_raw = m.group('ports')
            elif m.group('ui2') and m.group('inst2') and m.group('side2'):
                # Legacy format: "Declare [Index Switch #1] inputs: (Index, Data, Case 1, Case 2, ...)"
                side = m.group('side2').lower()
                ui = m.group('ui2')
                inst = m.group('inst2')
                ports_raw = m.group('ports2')
            else:
                i += 1
                continue

            ports = _split_ports(ports_raw) if ports_raw else []
            steps.append(
                {
                    "kind": "declare",
                    "side": side,
                    "node": _tok_node(ui, inst),
                    "ports": ports,
                }
            )
            i += 1
            continue

        # SETUSER (multi-line)
        m = RX_SETUSER_HDR.match(L)
        if m:
            node = _tok_node(m.group("ui"), m.group("inst"))
            i += 1
            entries = []
            while i < N:
                S = lines[i].rstrip("\n")
                if _is_comment_or_header(S):
                    i += 1
                    continue
                m2 = RX_SET_KV.match(S)
                if not m2:
                    break
                entries.append({"key": m2.group("key").strip(), "val": m2.group("val").strip()})
                i += 1
            steps.append({"kind": "set_user", "node": node, "entries": entries})
            continue


        # SET (multi-line)
        m = RX_SET_HDR.match(L)
        if m:
            node = _tok_node(m.group("ui"), m.group("inst"))
            i += 1
            entries = []
            while i < N:
                S = lines[i].rstrip("\n")
                if _is_comment_or_header(S):
                    i += 1
                    continue
                m2 = RX_SET_KV.match(S)
                if not m2:
                    break
                entries.append({"key": m2.group("key").strip(), "val": m2.group("val").strip()})
                i += 1
            steps.append({"kind": "set", "node": node, "entries": entries})
            continue

        # CONNECT
        m = RX_CONNECT.match(L)
        if m:
            steps.append(
                {
                    "kind": "connect",
                    "from": _tok_node(m.group("fui"), m.group("finst")),
                    "from_port": m.group("fport").strip(),
                    "to": _tok_node(m.group("tui"), m.group("tinst")),
                    "to_port": m.group("tport").strip(),
                    "dotted": False,
                }
            )
            i += 1
            continue

        # RENAME NODE
        m = RX_RENAME_NODE.match(L)
        if m:
            steps.append(
                {
                    "kind": "rename_node",
                    "node": _tok_node(m.group("ui"), m.group("inst")),
                    "label": m.group("label"),
                }
            )
            i += 1
            continue

        # RENAME INPUT (optional)
        m = RX_RENAME_INPUT.match(L)
        if m:
            steps.append(
                {
                    "kind": "rename_input",
                    "node": _tok_node(m.group("ui"), m.group("inst")),
                    "old": m.group("old"),
                    "new": m.group("new"),
                }
            )
            i += 1
            continue

        # Unknown line ‚Üí skip
        i += 1

    return steps


def _parse_line(L: str) -> Optional[Any]:
    s = _strip_num(L)

    # Try quoted format first (Material exporter format): Create ShaderNode "Name#N" ["VARIANT"]
    if s.startswith("Create "):
        # Match: Create <bl_idname> "<label>#<inst>" ["<variant>"]
        m = re.match(r'Create\s+([A-Za-z0-9_\.]+)\s+"(.+?)#(\d+)"(?:\s+"(.+?)")?', s)
        if m:
            bl_idname = m.group(1)
            label = m.group(2)
            inst = m.group(3)
            variant = m.group(4) if m.group(4) else "‚Äî"
            return CreateStmt(node=NodeRef(ui_type=label, label=label, inst=inst, bl_idname=bl_idname), variant=variant)
    
    # Try square bracket format (v1.4): Create [ Type | Variant | ] ~ Label ~ #N ; type=BlIdName
    if s.startswith("Create "):
        m = re.match(r"Create\s+(\[.+?\].+)$", s)
        if m:
            full = m.group(1)
            node = _parse_node(full)
            m_br = re.search(r'\[\s*(.+?)\s*\]', full)
            variant = "‚Äî"
            if m_br:
                parts = [p.strip() for p in m_br.group(1).split('|')]
                if len(parts) >= 2 and parts[1]:
                    variant = parts[1]
            return CreateStmt(node=node, variant=variant)

    if s.startswith("Declare "):
        m = re.match(r"Declare\s+(Inputs|Outputs)\s+(.+?)\s*:\s*(.+)$", s)
        if m:
            side = m.group(1).lower()
            node = _parse_node(m.group(2))
            ports = _split_ports(m.group(3))
            return DeclareStmt(side=side, node=node, ports=ports)

    if s.startswith("Declare "):
        # Style A: "Declare Inputs <node> : ( ... )"
        m = re.match(r"Declare\s+(Inputs|Outputs)\s+(.+?)\s*:\s*\((.*)\)\s*$", s)
        if m:
            side = m.group(1).lower()
            node = _parse_node(m.group(2))
            ports = _split_ports(m.group(3))
            return DeclareStmt(side=side, node=node, ports=ports)

        # Style B: "Declare [ <ui> #<n> ] inputs: ( ... )"
        m2 = re.match(r"Declare\s*\[\s*(.+?)\s*#(\d+)\s*\]\s*(inputs|outputs)\s*:\s*\((.*?)\)\s*$", s, flags=re.I)
        if m2:
            side = m2.group(3).lower()
            ui   = m2.group(1).strip()
            inst = m2.group(2).strip()
            ports = _split_ports(m2.group(4))
            # Build NodeRef directly to avoid depending on bracket formatting variants
            return DeclareStmt(side=side, node=NodeRef(ui_type=ui, label="", inst=inst, bl_idname=None), ports=ports)

        # Style C: "Declare Inputs [node] : ports" (export format)
        m3 = re.match(r"Declare\s+(Inputs|Outputs)\s*\[\s*(.+?)\s*#(\d+)\s*\]\s*:\s*(.+)$", s, flags=re.I)
        if m3:
            side = m3.group(1).lower()
            ui   = m3.group(2).strip()
            inst = m3.group(3).strip()
            ports = _split_ports(m3.group(4))
            return DeclareStmt(side=side, node=NodeRef(ui_type=ui, label="", inst=inst, bl_idname=None), ports=ports)

        # Style D: "Declare Inputs [ Group Input ]  ~~ name:type | name:type" (compositor interface format)
        m4 = re.match(r"Declare\s+(Inputs|Outputs)\s*\[\s*(.+?)\s*\]\s*~~\s*(.+)$", s, flags=re.I)
        if m4:
            side = m4.group(1).lower()
            node_name = m4.group(2).strip()
            ports_str = m4.group(3).strip()
            # Parse ports in format "name:type | name:type"
            # Extract just the names (before the colon) from each port
            ports = []
            for part in ports_str.split('|'):
                part = part.strip()
                if ':' in part:
                    # Extract name before colon (e.g., "Image" from "Image:NodeSocketColor")
                    port_name = part.split(':')[0].strip()
                    ports.append(port_name)
                elif part:  # fallback if no type specified
                    ports.append(part)
            # Infer inst from node name (Group Input/Output are always instance #1)
            return DeclareStmt(side=side, node=NodeRef(ui_type=node_name, label="", inst="1", bl_idname=None), ports=ports)

    if s.startswith("Connect"):
        # allow both "Connect" and "Connect‚ãØ" (Unicode ellipsis or triple dots)
        s_clean = s.replace("‚ãØ", "...").replace("‚Ä¶", "...")
        m = re.match(
            r"^Connect(?:[‚ãØ\.]*)\s*\[\s*(?P<fui>.+?)\s*#(?P<finst>\d+)\s*\]\s*‚óã\s*(?P<fport>.+?)\s*to\s*\[\s*(?P<tui>.+?)\s*#(?P<tinst>\d+)\s*\]\s*‚¶ø\s*(?P<tport>.+?)\s*$",
            s_clean, flags=re.I
        )
        if m:
            return ConnectStmt(
                from_=NodeRef(m.group("fui"), "", m.group("finst"), None),
                from_port=m.group("fport").strip(),
                to=NodeRef(m.group("tui"), "", m.group("tinst"), None),
                to_port=m.group("tport").strip(),
                dotted=False
            )


    if s.startswith("PairZone"):
        m = re.match(r"PairZone\s+\[\s*(Simulation|Repeat)\s+Input\s+#(\d+)\s*\]\s*<->\s*\[\s*(?:\1)\s+Output\s+#(\d+)\s*\]", s)
        if m:
            kind = m.group(1)
            left = NodeRef(ui_type=f"{kind} Input", label="", inst=m.group(2), bl_idname=None)
            right = NodeRef(ui_type=f"{kind} Output", label="", inst=m.group(3), bl_idname=None)
            return PairZoneStmt(kind=kind, left=left, right=right)

    # Parent [ Instance#N ] to [ Instance#M ] (Material format with instance names)
    if s.startswith("Parent"):
        m = re.match(r'Parent\s+\[\s*(.+?)#(\d+)\s*\]\s+to\s+\[\s*(.+?)#(\d+)\s*\]', s, re.I)
        if m:
            child_ui_type, child_inst = m.group(1).strip(), m.group(2)
            parent_ui_type, parent_inst = m.group(3).strip(), m.group(4)
            # Return dict matching material's idmap structure (tuples of ui_type, inst)
            return {'kind': 'parent', 
                    'child': {'ui_type': child_ui_type, 'inst': child_inst}, 
                    'parent': {'ui_type': parent_ui_type, 'inst': parent_inst}}

    return None

def parse_bndl(text: str) -> BNDLDoc:
    lines = [ln.rstrip('\r\n') for ln in text.splitlines()]
    version = "v1.x"
    groups: List[GroupDef] = []
    top_steps: List[Any] = []

    # version
    for ln in lines:
        if ln.strip().startswith("# BNDL"):
            m = re.search(r'#\s*BNDL\s*(v[0-9.]+)?', ln, flags=re.I)
            if m and m.group(1):
                version = m.group(1)
            break

    # ---- parse GROUP DEFINITIONS blocks ----
    i = 0
    while i < len(lines):
        ln = lines[i].strip()
        if ln.startswith("START GROUP NAMED"):
            m = re.match(r"START GROUP NAMED\s+(.+)$", ln)
            gname = (m.group(1).strip() if m else "NodeGroup")
            j = i + 1
            while j < len(lines) and not lines[j].strip().startswith("END GROUP NAMED"):
                j += 1
            block = lines[i+1:j] if j > i+1 else []
            steps = _parse_steps(block, f"group:{gname}")
            groups.append(GroupDef(name=gname, steps=steps))
            i = j + 1
            continue
        i += 1

    # ---- TOP LEVEL block ----
    start = end = -1
    for idx, ln in enumerate(lines):
        if ln.strip().startswith("# === TOP LEVEL ===") or ln.strip().startswith("# === MATERIAL TREE ==="):
            start = idx + 1
            break

    top_steps: List[Any] = []
    if start >= 0:
        # The "Top Level" block runs until the next section header,
        # BUT we also want to include the later "# === USER OVERRIDES ===" block
        # which contains SetUser entries for the Group Input UI.
        end = len(lines)
        for k in range(start + 1, len(lines)):
            if lines[k].strip().startswith("# ==="):
                end = k
                break
        top_steps = _parse_steps(lines[start:end], "top")

        # Additionally parse the USER OVERRIDES block if present and append
        uo_start = -1
        for idx, ln in enumerate(lines):
            if ln.strip().startswith("# === USER OVERRIDES ==="):
                uo_start = idx + 1
                break
        if uo_start >= 0:
            uo_end = len(lines)
            for k in range(uo_start + 1, len(lines)):
                if lines[k].strip().startswith("# ==="):
                    uo_end = k
                    break
            top_steps.extend(_parse_steps(lines[uo_start:uo_end], "top"))

    return BNDLDoc(version=version, groups=groups, top_steps=[s for s in top_steps if s is not None])

# --------------------------
# Replay code (emitted into Blender)
# --------------------------

def _header_lines() -> List[str]:
    H = []
    H.append("# BNDL_Replay.py ‚Äî generated by bndl2py")
    H.append("# Requires Blender 4.x")
    H.append("# BNDL2PY_VERSION: 1.4.1")
    H.append("import bpy, re, json, os")
    H.append("import math")
    H.append("from mathutils import Vector")
    H.append("")
    H.append("def _warn(msg): print(f\"[BNDL] WARNING: {msg}\")")
    H.append("def _info(msg): print(f\"[BNDL] {msg}\")")
    H.append("")
    H.append("_BNDL_TOUCHED = set()  # (id(node), label) tokens for first-write-wins on sockets")

    H.append("def _parse_value(text):")
    H.append("    # Accept scalars, tuples, and unit-suffixed tokens (¬∞, m).")
    H.append("    # IMPORTANT: if value is already numeric/tuple, return as-is (do NOT stringify).")
    H.append("    import re, math")
    H.append("    if isinstance(text, (int, float, bool, tuple, list)):")
    H.append("        return text")
    H.append("    t = str(text).strip()")
    H.append("    # Enum wrapper ¬©Name¬©")
    H.append("    m = re.match(r'^¬©\\s*(.*?)\\s*¬©$', t)")
    H.append("    if m: return m.group(1)")
    H.append("    # Angle/tuple wrapper <...> possibly comma-separated")
    H.append("    m = re.match(r'^<\\s*(.*?)\\s*>$', t)")
    H.append("    if m:")
    H.append("        inner = m.group(1).strip()")
    H.append("        # Tuples: split top-level by commas")
    H.append("        if ',' in inner:")
    H.append("            parts = [p.strip() for p in inner.split(',')]")
    H.append("            return tuple(_parse_value(f'<{p}>') for p in parts)")
    H.append("        s = inner")
    H.append("        low = s.lower()")
    H.append("        # booleans")
    H.append("        if low in ('true','false'): return (low=='true')")
    H.append("        # strip simple unit suffixes")
    H.append("        is_deg = False")
    H.append("        if low.endswith('¬∞') or low.endswith(' deg'):")
    H.append("            is_deg = True")
    H.append("            s = s[:-1] if low.endswith('¬∞') else s[:-4]")
    H.append("            s = s.strip()")
    H.append("        # meters (e.g., '1.0 m' or '1m')")
    H.append("        if s.endswith('m') and (len(s)==1 or s[-2].isdigit() or s[-2]=='.'):")
    H.append("            s = s[:-1].strip()")
    H.append("        # numeric parse")
    H.append("        try:")
    H.append("            v = float(s) if ('.' in s or 'e' in s.lower()) else int(s)")
    H.append("            if is_deg: v = math.radians(v)")
    H.append("            return v")
    H.append("        except Exception:")
    H.append("            return inner")
    H.append("    # bare boolean?")
    H.append("    if t.lower() == 'true': return True")
    H.append("    if t.lower() == 'false': return False")
    H.append("    # bare numeric?")
    H.append("    try:")
    H.append("        return float(t) if ('.' in t or 'e' in t.lower()) else int(t)")
    H.append("    except Exception:")
    H.append("        # Handle text sentinels for string values")
    H.append("        if t.startswith('~') and t.endswith('~'):")
    H.append("            return _unmark_text(t)")
    H.append("        return t")
    H.append("")

    H.append("def _unmark_text(s):")
    H.append("    # Remove BNDL wrappers from text values, e.g., ~text~, ¬©text¬©, ¬ßtext¬ß, and quotes.")
    H.append("    if not isinstance(s, str):")
    H.append("        s = str(s)")
    H.append("    # First strip any whitespace")
    H.append("    t = s.strip()")
    H.append("    # Remove outer section markers ¬ß if present")
    H.append("    if t.startswith('¬ß ') and t.endswith(' ¬ß'):")
    H.append("        t = t[2:-2].strip()")
    H.append("    elif t.startswith('¬ß') and t.endswith('¬ß'):")
    H.append("        t = t[1:-1].strip()")
    H.append("    # Now recursively strip other markers")
    H.append("    while len(t) >= 2:")
    H.append("        changed = False")
    H.append("        if t.startswith('~') and t.endswith('~'):")
    H.append("            t = t[1:-1].strip()")
    H.append("            changed = True")
    H.append("        elif t.startswith('¬©') and t.endswith('¬©'):")
    H.append("            t = t[1:-1].strip()")
    H.append("            changed = True")
    H.append("        elif t[0] in \"'\\\"\" and t[-1] == t[0]:")
    H.append("            t = t[1:-1].strip()")
    H.append("            changed = True")
    H.append("        if not changed:")
    H.append("            break")
    H.append("    return t")
    H.append("")

    H.append("def _set_enum_by_ui_label(node, prop_id, ui_label):")
    H.append("    try: prop = node.bl_rna.properties[prop_id]")
    H.append("    except Exception: return False")
    H.append("    try:")
    H.append("        for it in prop.enum_items:")
    H.append("            if getattr(it, 'name','') == ui_label:")
    H.append("                setattr(node, prop_id, it.identifier); return True")
    H.append("    except Exception: pass")
    H.append("    return False")
    H.append("")

    H.append("def _coerce_for_socket(sock, raw):")
    H.append("    # Datablocks first (unwrap sentinels and create proxies if needed).")
    H.append("    import bpy")
    H.append("    txt = _parse_value(raw)")
    H.append("    def _unwrap(symbol):")
    H.append("        s = str(raw)")
    H.append("        return s[len(symbol):-len(symbol)] if s.startswith(symbol) and s.endswith(symbol) else None")
    H.append("    sid = getattr(sock, 'bl_idname', '') or type(sock).__name__")

    H.append("    # Pointer-y sockets by idname")
    H.append("    if 'Object' in sid:")
    H.append("        reuse = bool(globals().get('BNDL_REUSE_PROXIES', True))")
    H.append("        name = _unwrap('‚äû') or str(txt)")
    H.append("        proxy_name = f\"bndlproxy_{name}\" if name else 'bndlproxy'")
    H.append("        ob = bpy.data.objects.get(name)")
    H.append("        if ob is not None:")
    H.append("            return ob")
    H.append("        if reuse:")
    H.append("            ob = bpy.data.objects.get(proxy_name)")
    H.append("            if ob is None:")
    H.append("                ob = bpy.data.objects.new(name=proxy_name, object_data=None)")
    H.append("                try:")
    H.append("                    scene = bpy.context.scene")
    H.append("                    if scene:")
    H.append("                        scene.collection.objects.link(ob)")
    H.append("                except Exception:")
    H.append("                    pass")
    H.append("            return ob")
    H.append("        ob = bpy.data.objects.new(name=proxy_name, object_data=None)")
    H.append("        try:")
    H.append("            scene = bpy.context.scene")
    H.append("            if scene:")
    H.append("                scene.collection.objects.link(ob)")
    H.append("        except Exception:")
    H.append("            pass")
    H.append("        return ob")

    H.append("    if 'Material' in sid:")
    H.append("        reuse = bool(globals().get('BNDL_REUSE_PROXIES', True))")
    H.append("        name = _unwrap('‚ùÜ') or str(txt)")
    H.append("        proxy_name = f\"bndlproxy_{name}\" if name else 'bndlproxy'")
    H.append("        mat = bpy.data.materials.get(name)")
    H.append("        if mat is not None:")
    H.append("            return mat")
    H.append("        if reuse:")
    H.append("            mat = bpy.data.materials.get(proxy_name)")
    H.append("            if mat is None:")
    H.append("                mat = bpy.data.materials.new(name=proxy_name)")
    H.append("            return mat")
    H.append("        return bpy.data.materials.new(name=proxy_name)")

    H.append("    if 'Collection' in sid or 'GeometryNodeCollection' in sid:")
    H.append("        reuse = bool(globals().get('BNDL_REUSE_PROXIES', True))")
    H.append("        name = _unwrap('‚ú∏') or str(txt)")
    H.append("        proxy_name = f\"bndlproxy_{name}\" if name else 'bndlproxy'")
    H.append("        col = bpy.data.collections.get(name)")
    H.append("        if col is not None:")
    H.append("            return col")
    H.append("        def _link_collection(db):")
    H.append("            try:")
    H.append("                scene = bpy.context.scene")
    H.append("                if scene:")
    H.append("                    scene.collection.children.link(db)")
    H.append("            except Exception:")
    H.append("                pass")
    H.append("        if reuse:")
    H.append("            col = bpy.data.collections.get(proxy_name)")
    H.append("            if col is None:")
    H.append("                col = bpy.data.collections.new(name=proxy_name)")
    H.append("                _link_collection(col)")
    H.append("            return col")
    H.append("        col = bpy.data.collections.new(name=proxy_name)")
    H.append("        _link_collection(col)")
    H.append("        return col")

    H.append("    if 'Image' in sid:")
    H.append("        reuse = bool(globals().get('BNDL_REUSE_PROXIES', True))")
    H.append("        name = _unwrap('‚ú∑') or str(txt)")
    H.append('        name = name.strip("\'")')
    H.append("        name = name.strip('\"')")
    H.append("        proxy_name = f\"bndlproxy_{name}\" if name else 'bndlproxy'")
    H.append("        img = bpy.data.images.get(name)")
    H.append("        if img is None:")
    H.append("            try:")
    H.append("                img = bpy.data.images.load(name)")
    H.append("                print(f\"[DEBUG] Loaded image '{name}' from absolute/CWD path\")")
    H.append("            except Exception:")
    H.append("                try:")
    H.append("                    img = bpy.data.images.load('//' + name)")
    H.append("                    print(f\"[DEBUG] Loaded image '{name}' from relative path\")")
    H.append("                except Exception:")
    H.append("                    # Try BNDL_ASSETS_PATH")
    H.append("                    assets_path = globals().get('BNDL_ASSETS_PATH')")
    H.append("                    if assets_path:")
    H.append("                        try:")
    H.append("                            img = bpy.data.images.load(os.path.join(assets_path, name))")
    H.append("                            print(f\"[DEBUG] Loaded image '{name}' from BNDL_ASSETS_PATH\")")
    H.append("                            return img")
    H.append("                        except Exception: pass")
    H.append("                    img = None")
    H.append("                    print(f\"[DEBUG] Failed to load image '{name}'\")")
    H.append("        if img is not None:")
    H.append("            return img")
    H.append("        if reuse:")
    H.append("            img = bpy.data.images.get(proxy_name)")
    H.append("            if img is None:")
    H.append("                img = bpy.data.images.new(name=proxy_name, width=1, height=1)")
    H.append("            return img")
    H.append("        return bpy.data.images.new(name=proxy_name, width=1, height=1)")

    H.append("    if 'Mesh' in sid:")
    H.append("        reuse = bool(globals().get('BNDL_REUSE_PROXIES', True))")
    H.append("        name = _unwrap('‚ßâ') or str(txt)")
    H.append("        proxy_name = f\"bndlproxy_{name}\" if name else 'bndlproxy'")
    H.append("        me = bpy.data.meshes.get(name)")
    H.append("        if me is not None:")
    H.append("            return me")
    H.append("        if reuse:")
    H.append("            me = bpy.data.meshes.get(proxy_name)")
    H.append("            if me is None:")
    H.append("                me = bpy.data.meshes.new(name=proxy_name)")
    H.append("            return me")
    H.append("        return bpy.data.meshes.new(name=proxy_name)")

    H.append("    if 'Curve' in sid:")
    H.append("        reuse = bool(globals().get('BNDL_REUSE_PROXIES', True))")
    H.append("        name = _unwrap('ùíû') or str(txt)")
    H.append("        proxy_name = f\"bndlproxy_{name}\" if name else 'bndlproxy'")
    H.append("        cu = bpy.data.curves.get(name)")
    H.append("        if cu is not None:")
    H.append("            return cu")
    H.append("        if reuse:")
    H.append("            cu = bpy.data.curves.get(proxy_name)")
    H.append("            if cu is None:")
    H.append("                cu = bpy.data.curves.new(name=proxy_name, type='CURVE')")
    H.append("            return cu")
    H.append("        return bpy.data.curves.new(name=proxy_name, type='CURVE')")

    H.append("    if 'String' in sid:")
    H.append("        # Accept enums ¬©‚Ä¶¬©, quoted strings, or bare text via _parse_value")
    H.append("        v = _parse_value(raw)")
    H.append("        return '' if v is None else str(v)")

    H.append("    # Now coerce numerics by socket type.")
    H.append("    # Accept: NodeSocketFloat, NodeSocketInt, NodeSocketBool, NodeSocketVector, NodeSocketColor, NodeSocketRotation")
    H.append("    st = sid")
    H.append("    def as_float(v):")
    H.append("        if isinstance(v, (int, float)): return float(v)")
    H.append("        return float(_parse_value(v))")
    H.append("    def as_int(v):")
    H.append("        if isinstance(v, bool): return int(v)")
    H.append("        if isinstance(v, int): return v")
    H.append("        return int(round(as_float(v)))")
    H.append("    def as_bool(v):")
    H.append("        if isinstance(v, bool): return v")
    H.append("        if isinstance(v, (int, float)): return bool(v)")
    H.append("        s = str(v).strip().lower()")
    H.append("        return s in ('1','true','yes','on')")
    H.append("    def as_vec3(v):")
    H.append("        if isinstance(v, (list, tuple)):")
    H.append("            if len(v) == 3: return tuple(float(x) for x in v)")
    H.append("            if len(v) == 1: return (float(v[0]),)*3")
    H.append("        if isinstance(v, (int, float)): return (float(v),)*3")
    H.append("        vv = _parse_value(v)")
    H.append("        return as_vec3(vv)")
    H.append("    def as_rgba(v):")
    H.append("        if isinstance(v, (list, tuple)):")
    H.append("            vv = tuple(float(x) for x in v)")
    H.append("            if len(vv) == 3: return vv + (1.0,)")
    H.append("            if len(vv) >= 4: return vv[:4]")
    H.append("        f = as_float(v)")
    H.append("        return (f, f, f, 1.0)")
    H.append("    # Map bl_idname/type ‚Üí coercer")
    H.append("    if 'Bool' in st:    return as_bool(txt)")
    H.append("    if 'Int' in st:     return as_int(txt)")
    H.append("    if 'Color' in st:   return as_rgba(txt)")
    H.append("    if 'Vector' in st or 'Rotation' in st: return as_vec3(txt)")
    H.append("    if 'Float' in st or 'Value' in st or not hasattr(sock,'default_value'):")
    H.append("        return as_float(txt)")
    H.append("    # Fallback")
    H.append("    return txt")
    H.append("")

    H.append("# === Implicit-conversion adapters (Vector‚ÜíFloat and Float‚ÜíVector) ===")
    H.append("_ADAPTERS = {")
    H.append("    'sep_xyz': {},   # key=(id(src.node), src_socket_name) -> SeparateXYZ node")
    H.append("    'com_xyz': {},   # key=(id(src.node), src_socket_name) -> CombineXYZ node")
    H.append("}")
    H.append("")
    H.append("def _get_sep_xyz(nt, src_socket, dst_node=None):")
    H.append("    key = (id(src_socket.node), getattr(src_socket, 'name', ''))")
    H.append("    n = _ADAPTERS['sep_xyz'].get(key)")
    H.append("    if n is None:")
    H.append("        try:")
    H.append("            n = nt.nodes.new('FunctionNodeSeparateXYZ')")
    H.append("        except Exception:")
    H.append("            n = nt.nodes.new('ShaderNodeSeparateXYZ')")
    H.append("        try:")
    H.append("            sx, sy = getattr(src_socket.node, 'location', (0, 0))")
    H.append("            if dst_node is not None:")
    H.append("                dx, dy = getattr(dst_node, 'location', (0, 0))")
    H.append("                n.location = ((sx + dx) * 0.5 - 40, (sy + dy) * 0.5)")
    H.append("            else:")
    H.append("                n.location = (sx + 120, sy)")
    H.append("        except Exception:")
    H.append("            pass")
    H.append("        try: nt.links.new(src_socket, n.inputs.get('Vector', n.inputs[0]))")
    H.append("        except Exception: pass")
    H.append("        _ADAPTERS['sep_xyz'][key] = n")
    H.append("    return n")
    H.append("")
    H.append("def _get_com_xyz(nt, src_socket, dst_node=None):")
    H.append("    key = (id(src_socket.node), getattr(src_socket, 'name', ''))")
    H.append("    n = _ADAPTERS['com_xyz'].get(key)")
    H.append("    if n is None:")
    H.append("        try:")
    H.append("            n = nt.nodes.new('ShaderNodeCombineXYZ')")
    H.append("        except Exception:")
    H.append("            try:")
    H.append("                n = nt.nodes.new('FunctionNodeCombineXYZ')")
    H.append("            except Exception:")
    H.append("                n = None")
    H.append("        if n is not None:")
    H.append("            try:")
    H.append("                sx, sy = getattr(src_socket.node, 'location', (0, 0))")
    H.append("                if dst_node is not None:")
    H.append("                    dx, dy = getattr(dst_node, 'location', (0, 0))")
    H.append("                    n.location = ((sx + dx) * 0.5 - 40, (sy + dy) * 0.5)")
    H.append("                else:")
    H.append("                    n.location = (sx + 120, sy)")
    H.append("            except Exception:")
    H.append("                pass")
    H.append("            try:")
    H.append("                nt.links.new(src_socket, n.inputs.get('X', n.inputs[0]))")
    H.append("                nt.links.new(src_socket, n.inputs.get('Y', n.inputs[1]))")
    H.append("                nt.links.new(src_socket, n.inputs.get('Z', n.inputs[2]))")
    H.append("            except Exception:")
    H.append("                pass")
    H.append("            _ADAPTERS['com_xyz'][key] = n")
    H.append("    return n")
    H.append("")
    H.append("def _link_with_adapters(nt, sa, sb):")
    H.append("    \"\"\"Return True if we handled the link (by inserting an adapter).")
    H.append("    Return False to let the caller link directly with links.new(sa, sb).\"\"\"")
    H.append("    sid = getattr(sa, 'bl_socket_idname', '') or type(sa).__name__")
    H.append("    tid = getattr(sb, 'bl_socket_idname', '') or type(sb).__name__")
    H.append("    dn  = getattr(sb, 'name', '').strip()")
    H.append("    # Vector ‚Üí Float on X/Y/Z inputs ‚Üí SeparateXYZ route")
    H.append("    if ('Vector' in sid) and ('Float' in tid) and dn in {'X','Y','Z'}:")
    H.append("        sep = _get_sep_xyz(nt, sa, getattr(sb, 'node', None))")
    H.append("        out = sep.outputs.get(dn) or sep.outputs[{'X':0,'Y':1,'Z':2}[dn]]")
    H.append("        try:")
    H.append("            nt.links.new(out, sb)")
    H.append("            return True")
    H.append("        except Exception:")
    H.append("            return False")
    H.append("    # Float/Int/Value ‚Üí Vector ‚Üí CombineXYZ splat")
    H.append("    if (('Float' in sid) or ('Int' in sid) or ('Value' in sid)) and ('Vector' in tid):")
    H.append("        com = _get_com_xyz(nt, sa, getattr(sb, 'node', None))")
    H.append("        if com is not None:")
    H.append("            try:")
    H.append("                nt.links.new(com.outputs.get('Vector', com.outputs[0]), sb)")
    H.append("                return True")
    H.append("            except Exception:")
    H.append("                return False")
    H.append("    # Not handled ‚Üí let caller link directly")
    H.append("    return False")
    H.append("")

    # --- BNDL2PY_STRING_HELPERS ---
    H.append("def _bndl_parse_string_literal(raw):")
    H.append("    if raw is None:")
    H.append("        return \"\"")
    H.append("    s = str(raw).strip()")
    H.append("    s = s.replace(\"‚Äú\", '\"').replace(\"‚Äù\", '\"').replace(\"‚Äò\", \"'\").replace(\"‚Äô\", \"'\")")
    H.append("    if len(s) >= 2 and s[0] == s[-1] and s[0] in ('\"', \"'\"):")
    H.append("        return s[1:-1]")
    H.append("    return s")
    H.append("")

    H.append("def _bndl_set_string(node, dest, value_str, log):")
    H.append("    v = _bndl_parse_string_literal(value_str)")
    H.append("    # dest may be a socket object OR an RNA property identifier (str)")
    H.append("    try:")
    H.append("        if hasattr(dest, 'bl_socket_idname') and hasattr(dest, 'default_value'):")
    H.append("            dest.default_value = v")
    H.append("            return True")
    H.append("    except Exception:")
    H.append("        pass")
    H.append("    try:")
    H.append("        if isinstance(dest, str):")
    H.append("            setattr(node, dest, v)")
    H.append("            return True")
    H.append("    except Exception as e:")
    H.append("        log('warn', 'string-set-failed', node=getattr(node,'name',node), key=str(dest), value=v, err=str(e))")
    H.append("    return False")
    H.append("")
    H.append("# --- /BNDL2PY_STRING_HELPERS ---")

    H.append("_PENDING_GI_DEFAULTS = {}  # key: ng (id of node_tree), val: list[(key, val)]")
    H.append("_PENDING_GI_OVERRIDES = {}  # key: ng (id of node_tree), val: dict[name -> raw_val]")
    H.append("_GI_APPLIED = {}  # key: id(ng) -> dict{name -> {'default': val, 'override': val}} used to mirror into the modifier")
    H.append("")
    H.append("def _normalize_gi_key(raw):")
    H.append("    if raw is None:")
    H.append("        return ''")
    H.append("    s = str(raw).strip()")
    H.append("    if s.startswith('¬ß'):")
    H.append("        s = s[1:].strip()")
    H.append("    if s.endswith('¬ß'):")
    H.append("        s = s[:-1].strip()")
    H.append("    s = s.replace(' ¬ß ', '::')")
    H.append("    s = s.replace(':: ', '::').replace(' ::', '::')")
    H.append("    return s")
    H.append("")
    H.append("def _queue_gi_default(ng, key, val):")
    H.append("    # ng is a bpy.types.NodeTree; store by id() to avoid name collisions")
    H.append("    bucket = _PENDING_GI_DEFAULTS.setdefault(id(ng), [])")
    H.append("    bucket.append((_normalize_gi_key(key), val))")
    H.append("")
    H.append("def _queue_gi_override(ng, key, val):")
    H.append("    store = _PENDING_GI_OVERRIDES.setdefault(id(ng), {})")
    H.append("    store[_normalize_gi_key(key)] = val")
    H.append("")



    H.append("def _apply_pending_gi_defaults(ng):")
    H.append("    import bpy, re")
    H.append("    items = _PENDING_GI_DEFAULTS.pop(id(ng), [])")
    H.append("    overrides = _PENDING_GI_OVERRIDES.pop(id(ng), {})")
    H.append("    if not items and not overrides: return")
    H.append("    applied = {}  # name -> dict of coerced values {'default': ..., 'override': ...}")

    H.append("")

    H.append("    # Build INPUT-side interface socket lookup by name")
    H.append("    iface = ng.interface")
    H.append("    try: tree_items = list(getattr(iface, 'items_tree', []))")
    H.append("    except Exception: tree_items = []")
    H.append("    if (items or overrides) and not tree_items:")
    H.append("        # Blender may delay populating interface.items_tree until after an update.")
    H.append("        try: ng.interface_update(bpy.context)")
    H.append("        except Exception: pass")
    H.append("        try: tree_items = list(getattr(iface, 'items_tree', []))")
    H.append("        except Exception: tree_items = []")
    H.append("    gi = [it for it in tree_items if getattr(it,'item_type','')=='SOCKET' and getattr(it,'in_out','')=='INPUT']")
    H.append("    by_name = { (getattr(it,'name','') or '').strip(): it for it in gi }")
    H.append("")
    H.append("    def _touch(name):")
    H.append("        name = (name or '').strip()")
    H.append("        entry = applied.get(name)")
    H.append("        if entry is None:")
    H.append("            entry = {}")
    H.append("            applied[name] = entry")
    H.append("        return entry")
    H.append("")
    H.append("    def _unwrap(sym, s):")
    H.append("        s = str(s)")
    H.append("        return s[len(sym):-len(sym)] if (s.startswith(sym) and s.endswith(sym)) else None")
    H.append("")
    H.append("    def _coerce_for_iface(it, raw):")
    H.append("        sid = (getattr(it,'bl_socket_idname','') or getattr(it,'socket_type','') or '')")
    H.append("        txt = _parse_value(raw)")
    H.append("        # Pointer-like sockets (datablocks)")
    H.append("        if 'Object' in sid:")
    H.append("            reuse = bool(globals().get('BNDL_REUSE_PROXIES', True))")
    H.append("            name = _unwrap('‚äû', raw) or str(txt)")
    H.append("            proxy_name = f\"bndlproxy_{name}\" if name else 'bndlproxy'")
    H.append("            ob = bpy.data.objects.get(name)")
    H.append("            if ob is not None:")
    H.append("                return ob")
    H.append("            if reuse:")
    H.append("                ob = bpy.data.objects.get(proxy_name)")
    H.append("                if ob is None:")
    H.append("                    ob = bpy.data.objects.new(name=proxy_name, object_data=None)")
    H.append("                    try:")
    H.append("                        scene = bpy.context.scene")
    H.append("                        if scene:")
    H.append("                            scene.collection.objects.link(ob)")
    H.append("                    except Exception:")
    H.append("                        pass")
    H.append("                return ob")
    H.append("            ob = bpy.data.objects.new(name=proxy_name, object_data=None)")
    H.append("            try:")
    H.append("                scene = bpy.context.scene")
    H.append("                if scene:")
    H.append("                    scene.collection.objects.link(ob)")
    H.append("            except Exception:")
    H.append("                pass")
    H.append("            return ob")
    H.append("        if 'Material' in sid:")
    H.append("            reuse = bool(globals().get('BNDL_REUSE_PROXIES', True))")
    H.append("            name = _unwrap('‚ùÜ', raw) or str(txt)")
    H.append("            proxy_name = f\"bndlproxy_{name}\" if name else 'bndlproxy'")
    H.append("            mat = bpy.data.materials.get(name)")
    H.append("            if mat is not None:")
    H.append("                return mat")
    H.append("            if reuse:")
    H.append("                mat = bpy.data.materials.get(proxy_name)")
    H.append("                if mat is None:")
    H.append("                    mat = bpy.data.materials.new(name=proxy_name)")
    H.append("                return mat")
    H.append("            return bpy.data.materials.new(name=proxy_name)")
    H.append("        if ('Collection' in sid) or ('GeometryNodeCollection' in sid):")
    H.append("            reuse = bool(globals().get('BNDL_REUSE_PROXIES', True))")
    H.append("            name = _unwrap('‚ú∏', raw) or str(txt)")
    H.append("            proxy_name = f\"bndlproxy_{name}\" if name else 'bndlproxy'")
    H.append("            col = bpy.data.collections.get(name)")
    H.append("            if col is not None:")
    H.append("                return col")
    H.append("            def _link_col(db):")
    H.append("                try:")
    H.append("                    scene = bpy.context.scene")
    H.append("                    if scene:")
    H.append("                        scene.collection.children.link(db)")
    H.append("                except Exception:")
    H.append("                    pass")
    H.append("            if reuse:")
    H.append("                col = bpy.data.collections.get(proxy_name)")
    H.append("                if col is None:")
    H.append("                    col = bpy.data.collections.new(name=proxy_name)")
    H.append("                    _link_col(col)")
    H.append("                return col")
    H.append("            col = bpy.data.collections.new(name=proxy_name)")
    H.append("            _link_col(col)")
    H.append("            return col")
    H.append("        if 'Image' in sid:")
    H.append("            reuse = bool(globals().get('BNDL_REUSE_PROXIES', True))")
    H.append("            name = _unwrap('‚ú∑', raw) or str(txt)")
    H.append("            proxy_name = f\"bndlproxy_{name}\" if name else 'bndlproxy'")
    H.append("            img = bpy.data.images.get(name)")
    H.append("            if img is None:")
    H.append("                try: img = bpy.data.images.load(name)")
    H.append("                except Exception:")
    H.append("                    try: img = bpy.data.images.load('//' + name)")
    H.append("                    except Exception: img = None")
    H.append("            if img is not None:")
    H.append("                return img")
    H.append("            if reuse:")
    H.append("                img = bpy.data.images.get(proxy_name)")
    H.append("                if img is None:")
    H.append("                    img = bpy.data.images.new(name=proxy_name, width=1, height=1)")
    H.append("                return img")
    H.append("            return bpy.data.images.new(name=proxy_name, width=1, height=1)")
    H.append("        # Numeric / vector / bool / string")
    H.append("        def as_float(v):")
    H.append("            if isinstance(v,(int,float)): return float(v)")
    H.append("            return float(_parse_value(v))")
    H.append("        def as_int(v):")
    H.append("            if isinstance(v,bool): return int(v)")
    H.append("            if isinstance(v,int): return v")
    H.append("            return int(round(as_float(v)))")
    H.append("        def as_bool(v):")
    H.append("            if isinstance(v,bool): return v")
    H.append("            if isinstance(v,(int,float)): return bool(v)")
    H.append("            s=str(v).strip().lower(); return s in {'1','true','yes','on'}")
    H.append("        def as_vec3(v):")
    H.append("            if isinstance(v,(list,tuple)):")
    H.append("                if len(v)==3: return tuple(float(x) for x in v)")
    H.append("                if len(v)==1: return (float(v[0]),)*3")
    H.append("            if isinstance(v,(int,float)): return (float(v),)*3")
    H.append("            return as_vec3(_parse_value(v))")
    H.append("        def as_color(v):")
    H.append("            if isinstance(v,(list,tuple)):")
    H.append("                vv=tuple(float(x) for x in v)")
    H.append("                if len(vv)==3: return vv+(1.0,)")
    H.append("                if len(vv)>=4: return vv[:4]")
    H.append("            f=as_float(v); return (f,f,f,1.0)")
    H.append("        st = sid or ''")
    H.append("        if 'Bool' in st: return as_bool(txt)")
    H.append("        if 'Int' in st: return as_int(txt)")
    H.append("        if 'Vector' in st or 'Rotation' in st: return as_vec3(txt)")
    H.append("        if 'Color' in st: return as_color(txt)")
    H.append("        if 'String' in st: return '' if txt is None else str(txt)")
    H.append("        # Floats / Value / fallback to float-ish")
    H.append("        return as_float(txt)")
    H.append("")
    H.append("    def _apply_iface_default(it, val):")
    H.append("        if it is None or val is None:")
    H.append("            return")
    H.append("        try:")
    H.append("            if hasattr(it, 'default_value'):")
    H.append("                it.default_value = val")
    H.append("            else:")
    H.append("                setattr(it, 'default_value', val)")
    H.append("        except Exception:")
    H.append("            pass")
    H.append("")
    H.append("    def _resolve_gi_socket(name):")
    H.append("        # Clean input - strip any section markers ¬ß")
    H.append("        cleaned = _unmark_text(str(name or ''))")
    H.append("        if not cleaned:")
    H.append("            return None")
    H.append("        # Handle paths like 'Geometry::Description' - look for 'Geometry' socket")
    H.append("        base = cleaned")
    H.append("        meta = None")
    H.append("        if '::' in cleaned:")
    H.append("            parts = cleaned.split('::', 1)")
    H.append("            base = (parts[0] or '').strip()")
    H.append("            meta = (parts[1] or '').strip().lower()")
    H.append("        try:")
    H.append("            # First try node group interface inputs")
    H.append("            sockets = getattr(ng, 'inputs', None)")
    H.append("            if sockets is not None:")
    H.append("                try: sock = sockets.get(base)")
    H.append("                except Exception: sock = None")
    H.append("                else:")
    H.append("                    if sock is not None:")
    H.append("                        return sock")
    H.append("        except Exception:")
    H.append("            pass")
    H.append("        try:")
    H.append("            for node in getattr(ng, 'nodes', []):")
    H.append("                if getattr(node, 'bl_idname', '') not in {'NodeGroupInput','GeometryNodeGroupInput'}:")
    H.append("                    continue")
    H.append("                for out in getattr(node, 'outputs', []):")
    H.append("                    nm = (getattr(out, 'name', '') or '').strip()")
    H.append("                    if nm == base:")
    H.append("                        return out")
    H.append("        except Exception:")
    H.append("            pass")
    H.append("        return None")
    H.append("")
    H.append("    def _apply_group_input_defaults(name, val):")
    H.append("        if val is None:")
    H.append("            return")
    H.append("        stripped = (name or '').strip()")
    H.append("        try:")
    H.append("            sockets = getattr(ng, 'inputs', None)")
    H.append("            if sockets is not None:")
    H.append("                try: sock = sockets.get(stripped)")
    H.append("                except Exception: sock = None")
    H.append("                if sock is not None and hasattr(sock, 'default_value'):")
    H.append("                    try: sock.default_value = val")
    H.append("                    except Exception: pass")
    H.append("        except Exception:")
    H.append("            pass")
    H.append("        try:")
    H.append("            for node in getattr(ng, 'nodes', []):")
    H.append("                if getattr(node, 'bl_idname', '') not in {'NodeGroupInput','GeometryNodeGroupInput'}:")
    H.append("                    continue")
    H.append("                for out in getattr(node, 'outputs', []):")
    H.append("                    nm = (getattr(out, 'name', '') or '').strip()")
    H.append("                    if nm != stripped:")
    H.append("                        continue")
    H.append("                    if hasattr(out, 'default_value'):")
    H.append("                        try: out.default_value = val")
    H.append("                        except Exception: pass")
    H.append("        except Exception:")
    H.append("            pass")
    H.append("")
    H.append("    def _apply_override_record(base, it, raw):")
    H.append("        if raw is None:")
    H.append("            return")
    H.append("        try:")
    H.append("            target = it")
    H.append("            if target is not None:")
    H.append("                val = _coerce_for_iface(target, raw)")
    H.append("            else:")
    H.append("                sock = _resolve_gi_socket(base)")
    H.append("                if sock is None:")
    H.append("                    val = _parse_value(raw)")
    H.append("                else:")
    H.append("                    val = _coerce_for_socket(sock, raw)")
    H.append("            slot = _touch(base)")
    H.append("            slot['override'] = val")
    H.append("        except Exception as ex:")
    H.append("            _warn(f'Failed GI override apply for {base}: {ex}')")
    H.append("")

    H.append("    # Apply queued entries (pre-parse so metadata runs before defaults)")
    H.append("    parsed = []")
    H.append("    for keytxt, raw in items:")
    H.append("        key = str(keytxt).strip()")
    H.append("        # Only treat meta-suffixes when they are explicitly delimited as 'Name::Meta'.")
    H.append("        base = key")
    H.append("        meta = None")
    H.append("        if '::' in key:")
    H.append("            parts = key.split('::', 1)")
    H.append("            base = (parts[0] or '').strip()")
    H.append("            meta = (parts[1] or '').strip().lower()")
    H.append("        it = by_name.get(base)")
    H.append("        parsed.append((base, meta, raw, key, it))")

    H.append("")
    H.append("    # Pass 1: metadata (socket types, ranges, descriptions, etc.)")
    H.append("    for base, meta, raw, key, it in parsed:")
    H.append("        if not base or meta in (None, 'default', 'default input'):")
    H.append("            continue")
    H.append("        try:")
    H.append("            # Try to find the socket first - either directly in interface by_name or from GI node")
    H.append("            target = it")
    H.append("            if target is None and base:")
    H.append("                target = _resolve_gi_socket(key)")  # Use the full key to preserve path
    H.append("            if target is None:")
    H.append("                continue")
    H.append("            if meta == 'min' and hasattr(target, 'min_value'):")
    H.append("                target.min_value = float(_parse_value(raw))")
    H.append("            elif meta == 'max' and hasattr(target, 'max_value'):")
    H.append("                target.max_value = float(_parse_value(raw))")
    H.append("            elif meta == 'description' and hasattr(target, 'description'):")
    H.append("                # Process description: unwrap all sentinels and normalize")
    H.append("                # Use _unmark_text to handle all sentinel types consistently")
    H.append("                val = _unmark_text(raw)")
    H.append("                try:")
    H.append("                    target.description = val")
    H.append("                except Exception:")
    H.append("                    target_name = getattr(target, 'name', '?')")
    H.append("                    _warn(f'Failed to set description on {target_name}: {val}')")
    H.append("            elif meta == 'subtype' and hasattr(it, 'subtype'):")
    H.append("                # strip surrounding quotes so enum identifiers match Blender's API values")
    H.append("                it.subtype = str(_parse_value(raw)).strip(\"'\\\"\")")
    H.append("            elif meta == 'default attribute' and hasattr(it, 'attribute_name'):")
    H.append("                it.attribute_name = str(_parse_value(raw))")
    H.append("            elif meta == 'hide value' and hasattr(it, 'hide_value'):")
    H.append("                it.hide_value = bool(_parse_value(raw))")
    H.append("            elif meta == 'hide in modifier' and hasattr(it, 'hide_in_modifier'):")
    H.append("                it.hide_in_modifier = bool(_parse_value(raw))")
    H.append("            elif meta == 'structure type' and hasattr(it, 'structure_type'):")
    H.append("                # strip surrounding quotes so enum identifiers like AUTO/SINGLE match")
    H.append("                it.structure_type = str(_parse_value(raw)).strip(\"'\\\"\")")
    H.append("            elif meta == 'socket type' and hasattr(it, 'socket_type'):")
    H.append("                stype = str(_parse_value(raw)).strip(\"'\\\"\")")
    H.append("                try: it.socket_type = stype")
    H.append("                except Exception: _warn(f\"Failed to set socket_type={stype!r} for {getattr(it, 'name', '?')}\")")
    H.append("            else:")
    H.append("                continue")
    H.append("        except Exception as ex:")
    H.append("            _warn(f'Failed GI meta apply for {base}::{meta}: {ex}')")

    H.append("")
    H.append("    # Pass 2: defaults and modifier overrides")
    H.append("    seen_override = set()")
    H.append("    for base, meta, raw, key, it in parsed:")
    H.append("        if not base:")
    H.append("            continue")
    H.append("        socket = it if it is not None else _resolve_gi_socket(base)")
    H.append("        if socket is None:")
    H.append("            continue")
    H.append("        try:")
    H.append("            if meta == 'default input':")
    H.append("                val = _coerce_for_iface(it, raw) if it is not None else _coerce_for_socket(socket, raw)")
    H.append("                slot = _touch(base)")
    H.append("                slot['default_input'] = val")
    H.append("                if it is not None and 'default' not in slot:")
    H.append("                    _apply_iface_default(it, val)")
    H.append("                _apply_group_input_defaults(base, val)")
    H.append("            elif meta in (None, 'default'):")
    H.append("                val = _coerce_for_iface(it, raw) if it is not None else _coerce_for_socket(socket, raw)")
    H.append("                slot = _touch(base)")
    H.append("                slot['default'] = val")
    H.append("                if it is not None:")
    H.append("                    _apply_iface_default(it, val)")
    H.append("                _apply_group_input_defaults(base, val)")
    H.append("            else:")
    H.append("                continue")
    H.append("        except Exception as ex:")
    H.append("            if meta == 'default input':")
    H.append("                _warn(f'Failed GI default input apply for {base}: {ex}')")
    H.append("            elif meta in (None, 'default'):")
    H.append("                _warn(f'Failed GI default apply for {base}: {ex}')")
    H.append("            else:")
    H.append("                _warn(f'Failed GI default apply for {base}::{meta}: {ex}')")
    H.append("")
    H.append("        if base not in seen_override:")
    H.append("            raw_override = overrides.pop(base, None)")
    H.append("            _apply_override_record(base, it, raw_override)")
    H.append("            seen_override.add(base)")

    H.append("")
    H.append("    # Apply overrides that only existed as SetUser entries")
    H.append("    for base, raw in list(overrides.items()):")
    H.append("        key = (base or '').strip()")
    H.append("        it = by_name.get(key)")
    H.append("        if not it and _resolve_gi_socket(key) is None:")
    H.append("            continue")
    H.append("        _apply_override_record(key, it, raw)")

    H.append("")
    H.append("    # Stash for the modifier mirror step (covers types with no readable default on the iface item)")
    H.append("    _GI_APPLIED[id(ng)] = applied")
    H.append("    # Give Blender a nudge so UI reflects changes")
    H.append("    try: ng.interface_update(bpy.context)")
    H.append("    except Exception: pass")
    H.append("def _mirror_gi_defaults_to_modifier(mod, ng):")
    H.append("    # Mirror GI defaults into the modifier UI using the values we actually applied,")
    H.append("    # because some interface items (esp. datablocks) don't expose a usable default_value.")
    H.append("    try:")
    H.append("        iface = ng.interface")
    H.append("        src = [it for it in getattr(iface,'items_tree',[]) if getattr(it,'item_type','')=='SOCKET' and getattr(it,'in_out','')=='INPUT']")
    H.append("        cache = _GI_APPLIED.get(id(ng), {})  # name -> dict of coerced values")
    H.append("        for it in src:")
    H.append("            name  = (getattr(it,'name', None) or '').strip()")
    H.append("            ident = getattr(it,'identifier', None) or name")
    H.append("            entry = cache.get(name, None)")
    H.append("            if isinstance(entry, dict):")
    H.append("                val_override = entry.get('override', None)")
    H.append("                val_default = entry.get('default', None)")
    H.append("                if val_default is None:")
    H.append("                    val_default = entry.get('default_input', None)")
    H.append("            else:")
    H.append("                val_override = None")
    H.append("                val_default = entry")
    H.append("            if val_default is None and isinstance(entry, dict):")
    H.append("                val_default = entry.get('default_input', None)")
    H.append("            val = val_override if val_override is not None else val_default")
    H.append("            if val is None:")
    H.append("                val = getattr(it, 'default_value', None)")
    H.append("            try:")
    H.append("                # GeometryNodes modifier exposes inputs by identifier; mapping works for")
    H.append("                # all supported types (ints, floats, vectors, bools, and datablock pointers).")
    H.append("                if ident in mod:")
    H.append("                    mod[ident] = val")
    H.append("                    continue")
    H.append("                if hasattr(mod, ident):")
    H.append("                    setattr(mod, ident, val)")
    H.append("                    continue")
    H.append("            except Exception:")
    H.append("                pass")
    H.append("    except Exception:")
    H.append("        pass")
    H.append("# --- /BNDL2PY_GI_DEFAULTS_QUEUE ---")
    H.append("")

    H.append("def _apply_kv(n, key, val):")
    H.append("    \"\"\"Apply a Set entry to either an INPUT socket or an RNA property.")
    H.append("    - Prefers INPUT sockets by visible label (e.g., 'Object').")
    H.append("    - If not found, tries a type-guided match for datablock sockets (Object/Collection/Material/Image/Mesh/Curve).")
    H.append("    - For sockets: first-write-wins; if socket is vector-like and value is scalar, ignore the write.")
    H.append("    - Falls back to RNA properties for ENUM/BOOLEAN/scalar props.")
    H.append("    \"\"\"")
    H.append("    import bpy")
    H.append("    global _BNDL_TOUCHED")
    H.append("")
    H.append("    print(f\"[DEBUG] _apply_kv called: key='{key}', val={val}, node={getattr(n,'name',type(n).__name__)}\")")

    H.append("    # Store Named Attribute: 'Name' must target the STRING INPUT socket, not Node.name")
    H.append("    try:")
    H.append("        if getattr(n, 'bl_idname', '') == 'GeometryNodeStoreNamedAttribute' and str(key).strip() == 'Name':")
    H.append("            s_name = resolve_socket_by_display(n, 'in', 'Name')")
    H.append("            if s_name is None: _warn(\"Socket 'Name' not found on Store Named Attribute.\"); return")
    H.append("            try: s_name.default_value = str(_parse_value(val))")
    H.append("            except Exception as ex: _warn(f\"Failed to set Store Named Attribute Name: {ex}\")")
    H.append("            return")
    H.append("    except Exception: pass")
    H.append("")

    H.append("    # Named Attribute (GeometryNodeInputNamedAttribute): set the STRING 'Name' input")
    H.append("    try:")
    H.append("        if getattr(n, 'bl_idname', '') == 'GeometryNodeInputNamedAttribute' and str(key).strip() == 'Name':")
    H.append("            s_name = resolve_socket_by_display(n, 'in', 'Name')")
    H.append("            if s_name is None: _warn(\"Socket 'Name' not found on Named Attribute.\"); return")
    H.append("            # accept ¬©‚Ä¶¬© or raw text")
    H.append("            try:")
    H.append("                sval = _parse_value(val)")
    H.append("                s_name.default_value = str(sval)")
    H.append("            except Exception as ex:")
    H.append("                _warn(f\"Failed to set Named Attribute Name: {ex}\")")
    H.append("            return")
    H.append("    except Exception:")
    H.append("        pass")

    H.append("    # --- Early handling: skip admin UI names and set ENUMs by UI label ---")
    H.append("    ADMIN_SKIP = {")
    H.append("        'Warning Propagation','Show Preview','Show Texture','Icon','Active Output',")
    H.append("        'Absolute Location','Distribution Method','Legacy Normal',")
    H.append("        'bl_width_default','bl_width_min','bl_width_max','bl_height_default','bl_height_min','bl_height_max'")
    H.append("    }")
    H.append("    if str(key).strip() in ADMIN_SKIP:")
    H.append("        return")
    H.append("")
    H.append("    # ENUMs like 'Data Type', 'Domain', 'Fill Type'‚Ä¶ should be applied via RNA, not sockets")
    H.append("    try:")
    H.append("        for p in n.bl_rna.properties:")
    H.append("            if getattr(p, 'name', '') != key:")
    H.append("                continue")
    H.append("            if p.type == 'ENUM':")
    H.append("                _set_enum_by_ui_label(n, p.identifier, str(val).strip('¬©'))")
    H.append("                return")
    H.append("    except Exception:")
    H.append("        pass")

    H.append("    # --- Group Input interface defaults: DEFER to queue (Blender 4.x) ---")
    H.append("    try:")
    H.append("        if getattr(n, 'bl_idname', '') in {'NodeGroupInput','GeometryNodeGroupInput'}:")
    H.append("            # Defer applying to ng.interface until AFTER rebuild_interface runs")
    H.append("            _queue_gi_default(n.id_data, key, val)")
    H.append("            return")
    H.append("    except Exception:")
    H.append("        pass")

    H.append("")
    H.append("    # --- Special handling for common node attributes (NOT sockets) ---")
    H.append("    # These are direct node properties that should be set before attempting socket resolution")
    H.append("    print(f'[BNDL-SPECIAL-HANDLING] Checking key: {key}')")
    H.append("    try:")
    H.append("        k_lower = str(key).strip().lower()")
    H.append("")
    H.append("        # Node position")
    H.append("        if k_lower == 'location':")
    H.append("            try:")
    H.append("                loc_val = _parse_value(val)")
    H.append("                if isinstance(loc_val, (tuple, list)) and len(loc_val) >= 2:")
    H.append("                    n.location = (float(loc_val[0]), float(loc_val[1]))")
    H.append("                    return")
    H.append("            except Exception as ex:")
    H.append("                _warn(f\"Failed to set location on {getattr(n,'name',type(n).__name__)}: {ex}\")")
    H.append("            return")
    H.append("")
    H.append("        # Node mute state")
    H.append("        if k_lower == 'mute':")
    H.append("            try:")
    H.append("                n.mute = bool(_parse_value(val))")
    H.append("                return")
    H.append("            except Exception as ex:")
    H.append("                _warn(f\"Failed to set mute on {getattr(n,'name',type(n).__name__)}: {ex}\")")
    H.append("            return")
    H.append("")
    H.append("        # Node hide state")
    H.append("        if k_lower == 'hide':")
    H.append("            try:")
    H.append("                n.hide = bool(_parse_value(val))")
    H.append("                return")
    H.append("            except Exception:")
    H.append("                pass")
    H.append("            return")
    H.append("")
    H.append("        # Node label")
    H.append("        if k_lower == 'label':")
    H.append("            try:")
    H.append("                n.label = str(_parse_value(val))")
    H.append("                return")
    H.append("            except Exception:")
    H.append("                pass")
    H.append("            return")
    H.append("")
    H.append("        # Image Texture node: image datablock")
    H.append("        if k_lower == 'image' and hasattr(n, 'image'):")
    H.append("            try:")
    H.append('                raw_name = str(val).strip().strip("\'")')
    H.append("                raw_name = raw_name.strip('\"')")
    H.append("                # Unwrap image sentinel ‚ú∑...‚ú∑")
    H.append("                if raw_name.startswith('‚ú∑') and raw_name.endswith('‚ú∑'):")
    H.append("                    img_name = raw_name[1:-1]")
    H.append("                else:")
    H.append("                    img_name = raw_name")
    H.append("")
    H.append("                # Try to load the image")
    H.append("                img = bpy.data.images.get(img_name)")
    H.append("                if img is None:")
    H.append("                    try:")
    H.append("                        img = bpy.data.images.load(img_name)")
    H.append("                        print(f\"[DEBUG] _apply_kv: Loaded image '{img_name}' from absolute/CWD path\")")
    H.append("                    except Exception:")
    H.append("                        try:")
    H.append("                            img = bpy.data.images.load('//' + img_name)")
    H.append("                            print(f\"[DEBUG] _apply_kv: Loaded image '{img_name}' from relative path\")")
    H.append("                        except Exception:")
    H.append("                            # Try BNDL_ASSETS_PATH")
    H.append("                            assets_path = globals().get('BNDL_ASSETS_PATH')")
    H.append("                            loaded_from_assets = False")
    H.append("                            if assets_path:")
    H.append("                                try:")
    H.append("                                    img = bpy.data.images.load(os.path.join(assets_path, img_name))")
    H.append("                                    print(f\"[DEBUG] _apply_kv: Loaded image '{img_name}' from BNDL_ASSETS_PATH\")")
    H.append("                                    loaded_from_assets = True")
    H.append("                                except Exception: pass")
    H.append("                            if not loaded_from_assets:")
    H.append("                                # Create a proxy image if file doesn't exist")
    H.append("                                print(f\"[DEBUG] _apply_kv: Creating proxy for '{img_name}'\")")
    H.append("                                img = bpy.data.images.new(name=f\"proxy_{img_name}\", width=1, height=1)")
    H.append("                n.image = img")
    H.append("                return")
    H.append("            except Exception as ex:")
    H.append("                _warn(f\"Failed to set image on {getattr(n,'name',type(n).__name__)}: {ex}\")")
    H.append("            return")
    H.append("")
    H.append("        # Image Texture node: interpolation enum")
    H.append("        if k_lower == 'interpolation' and hasattr(n, 'interpolation'):")
    H.append("            try:")
    H.append("                # Unwrap all sentinels first")
    H.append("                interp_val = _unmark_text(val)")
    H.append("                # Try setting by UI label first (this handles the enum properly)")
    H.append("                if not _set_enum_by_ui_label(n, 'interpolation', interp_val):")
    H.append("                    # Fallback: try direct assignment")
    H.append("                    n.interpolation = interp_val")
    H.append("                return")
    H.append("            except Exception as ex:")
    H.append("                _warn(f\"Failed to set interpolation on {getattr(n,'name',type(n).__name__)}: {ex}\")")
    H.append("            return")
    H.append("")
    H.append("        # Mix node: data_type enum (FLOAT, RGBA, VECTOR, etc.) - MUST be set before sockets are accessed!")
    H.append("        if k_lower == 'data_type' and hasattr(n, 'data_type'):")
    H.append("            try:")
    H.append("                # Unwrap all sentinels first")
    H.append("                dtype_val = _unmark_text(val)")
    H.append("                # Try setting by UI label first")
    H.append("                if not _set_enum_by_ui_label(n, 'data_type', dtype_val):")
    H.append("                    # Fallback: try direct assignment")
    H.append("                    n.data_type = dtype_val")
    H.append("                print(f\"[DEBUG] Set Mix node data_type to '{dtype_val}'\")")
    H.append("                return")
    H.append("            except Exception as ex:")
    H.append("                _warn(f\"Failed to set data_type on {getattr(n,'name',type(n).__name__)}: {ex}\")")
    H.append("            return")
    H.append("    except Exception:")
    H.append("        pass")

    H.append("")
    H.append("    # --- Prefer INPUT SOCKET by label ---")
    H.append("    print(f\"[DEBUG] Trying INPUT socket resolution for key '{key}'\")")
    H.append("    s = resolve_socket_by_display(n, 'in', str(key).strip())")
    H.append("    print(f\"[DEBUG] INPUT socket resolution result: {s}\")")
    H.append("    # Mix node special handling: if multiple sockets with same name, pick the one matching data_type")
    H.append("    print(f\"[DEBUG-MIX] Checking if Mix node refinement applies: hasattr(data_type)={hasattr(n, 'data_type')}, s={s is not None}\")")
    H.append("    if s is not None and hasattr(n, 'data_type'):")
    H.append("        try:")
    H.append("            dtype = getattr(n, 'data_type', None)")
    H.append("            print(f\"[DEBUG-MIX] Node data_type={dtype}, key={str(key).strip()}\")")
    H.append("            if dtype and str(key).strip() in ('A', 'B', 'Factor', 'Result'):")
    H.append("                # Get all sockets with this name")
    H.append("                sock_list = [sock for sock in getattr(n, 'inputs', []) if getattr(sock, 'name', '') == str(key).strip()]")
    H.append("                print(f\"[DEBUG-MIX] Found {len(sock_list)} sockets named '{str(key).strip()}'\")")
    H.append("                if len(sock_list) > 1:")
    H.append("                    # Multiple sockets - pick one matching data_type")
    H.append("                    type_map = {'RGBA': 'Color', 'FLOAT': 'Float', 'VECTOR': 'Vector', 'ROTATION': 'Rotation'}")
    H.append("                    wanted_type = type_map.get(dtype, 'Float')")
    H.append("                    print(f\"[DEBUG-MIX] Looking for socket type: {wanted_type}\")")
    H.append("                    for sock in sock_list:")
    H.append("                        sock_type = getattr(sock, 'bl_idname', '') or type(sock).__name__")
    H.append("                        print(f\"[DEBUG-MIX] Checking socket: {sock}, type={sock_type}\")")
    H.append("                        if wanted_type in sock_type:")
    H.append("                            s = sock")
    H.append("                            print(f\"[DEBUG] Mix node: refined socket to type {wanted_type}: {s}\")")
    H.append("                            break")
    H.append("        except Exception as ex:")
    H.append("            print(f\"[DEBUG] Mix node socket refinement failed: {ex}\")")
    H.append("")
    H.append("    # If not found, try a type-guided hunt for datablock pointer sockets")
    H.append("    if s is None:")
    H.append("        want_type = None")
    H.append("        lk = key.strip().lower()")
    H.append("        if   lk == 'object':      want_type = 'Object'")
    H.append("        elif lk == 'collection':  want_type = 'Collection'")
    H.append("        elif lk == 'material':    want_type = 'Material'")
    H.append("        elif lk == 'image':       want_type = 'Image'")
    H.append("        elif lk == 'mesh':        want_type = 'Mesh'")
    H.append("        elif lk == 'curve':       want_type = 'Curve'")
    H.append("        if want_type is not None:")
    H.append("            for cand in getattr(n, 'inputs', []):")
    H.append("                try:")
    H.append("                    sid = getattr(cand, 'bl_idname', '') or type(cand).__name__")
    H.append("                    if want_type in sid: s = cand; break")
    H.append("                except Exception: pass")
    H.append("")
    H.append("    # If we have a socket with a default_value, set it (covers pointer & numeric sockets)")
    H.append("    if s is not None and hasattr(s, 'default_value'):")
    H.append("        token = (id(n), str(key))")
    H.append("        if token in _BNDL_TOUCHED:")
    H.append("            return  # first-write-wins: later duplicates (e.g., scalar after vector) are ignored")
    H.append("        try:")
    H.append("            coerced = _coerce_for_socket(s, val)")
    H.append("            dv = s.default_value")
    H.append("            # If socket is vector-like but coerced is scalar, ignore the write.")
    H.append("            # This prevents 0/100 overwrites when a vector socket is implicitly set by a scalar.")
    H.append("            is_vec_sock = False")
    H.append("            try:")
    H.append("                sid = getattr(s, 'bl_idname', '') or getattr(s, 'type', '')")
    H.append("                if 'Vector' in sid: is_vec_sock = True")
    H.append("            except Exception: pass")
    H.append("            if is_vec_sock and not isinstance(coerced, (tuple, list)):")
    H.append("                return")
    H.append("            # For vector-like sockets: component-wise populate when lengths match")
    H.append("            try:")
    H.append("                from collections.abc import Sequence")
    H.append("                if isinstance(dv, Sequence) and not isinstance(dv, (str, bytes)):")
    H.append("                    L = None")
    H.append("                    try: L = len(dv)")
    H.append("                    except Exception: L = None")
    H.append("                    if L in (2,3,4) and isinstance(coerced, (tuple, list)) and len(coerced) >= L:")
    H.append("                        for i in range(L): dv[i] = float(coerced[i])")
    H.append("                        _BNDL_TOUCHED.add(token)")
    H.append("                        return")
    H.append("            except Exception: pass")
    H.append("            # Fallback: direct assignment")
    H.append("            s.default_value = coerced")
    H.append("            _BNDL_TOUCHED.add(token)")
    H.append("            return")
    H.append("        except Exception as ex:")
    H.append("            _warn(f\"Failed to set socket default on {getattr(n,'name',type(n).__name__)}.{key}: {ex}\")")
    H.append("            return")
    H.append("")
    H.append("    # --- OUTPUT SOCKET default (e.g., Value node's \"Value\" lives on outputs[0]) ---")
    H.append("    print(f\"[DEBUG] Trying OUTPUT socket resolution for key '{key}'\")")
    H.append("    if s is None:")
    H.append("        s_out = resolve_socket_by_display(n, 'out', str(key).strip())")
    H.append("        print(f\"[DEBUG] OUTPUT socket resolution result: {s_out}\")")
    H.append("        if s_out is not None and hasattr(s_out, 'default_value'):")
    H.append("            token = (id(n), str(key))")
    H.append("            if token in _BNDL_TOUCHED:")
    H.append("                return")
    H.append("            try:")
    H.append("                coerced = _coerce_for_socket(s_out, val)")
    H.append("                dv = s_out.default_value")
    H.append("                # Vector-like guard (avoid scalar into vector unless it actually fits)")
    H.append("                is_vec = False")
    H.append("                try:")
    H.append("                    _ = len(dv); is_vec = True")
    H.append("                except Exception:")
    H.append("                    pass")
    H.append("                if is_vec and not isinstance(coerced, (tuple, list)):")
    H.append("                    return")
    H.append("                # Component-wise update if dv is a sequence")
    H.append("                try:")
    H.append("                    from collections.abc import Sequence")
    H.append("                    if isinstance(dv, Sequence) and not isinstance(dv, (str, bytes)):")
    H.append("                        L = None")
    H.append("                        try: L = len(dv)")
    H.append("                        except Exception: L = None")
    H.append("                        if L in (2,3,4) and isinstance(coerced, (tuple, list)) and len(coerced) >= L:")
    H.append("                            for i in range(L): dv[i] = float(coerced[i])")
    H.append("                            _BNDL_TOUCHED.add(token); return")
    H.append("                except Exception: pass")
    H.append("                s_out.default_value = coerced")
    H.append("                _BNDL_TOUCHED.add(token)")
    H.append("                return")
    H.append("            except Exception as ex:")
    H.append("                _warn(f\"Failed to set output socket default on {getattr(n,'name',type(n).__name__)}.{key}: {ex}\")")
    H.append("                return")
    H.append("    # --- Handle curve mapping data (e.g., Float Curve, Color Ramp) ---")
    H.append("    print(f\"[DEBUG] About to check curve mapping for key: {key}\")")
    H.append("    import re")
    H.append("    print(f\"[DEBUG] Checking curve mapping for key: {key}\")")
    H.append("    m = re.match(r'^mapping\\.curve\\[(\\d+)\\]\\.points\\[(\\d+)\\]$', key)")
    H.append("    print(f\"[DEBUG] Curve regex match result: {m}\")")
    H.append("    if m:")
    H.append("        curve_idx, point_idx = int(m.group(1)), int(m.group(2))")
    H.append("        try:")
    H.append("            # Ensure node has mapping property")
    H.append("            if not hasattr(n, 'mapping'):")
    H.append("                _warn(f\"Node {getattr(n,'name',type(n).__name__)} has no mapping property for curve data\")")
    H.append("                return")
    H.append("            mapping = n.mapping")
    H.append("            print(f\"[DEBUG] Curve import: node={getattr(n,'name',type(n).__name__)}, curve_idx={curve_idx}, point_idx={point_idx}, val={val}\")")
    H.append("            # Ensure curve exists")
    H.append("            while len(mapping.curves) <= curve_idx:")
    H.append("                mapping.curves.new()")
    H.append("                print(f\"[DEBUG] Created new curve at index {len(mapping.curves)-1}\")")
    H.append("            curve = mapping.curves[curve_idx]")
    H.append("            print(f\"[DEBUG] Using curve {curve_idx}, total curves: {len(mapping.curves)}\")")
    H.append("            # Parse point data: <x,y,handle_type>")
    H.append("            val_str = str(val).strip('<>')")
    H.append("            parts = [p.strip() for p in val_str.split(',')]")
    H.append("            print(f\"[DEBUG] Parsed val_str='{val_str}', parts={parts}\")")
    H.append("            if len(parts) != 3:")
    H.append("                _warn(f\"Invalid curve point format: {val}\")")
    H.append("                return")
    H.append("            x, y = float(parts[0]), float(parts[1])")
    H.append("            handle_type = parts[2].upper()")
    H.append("            print(f\"[DEBUG] Parsed values: x={x}, y={y}, handle_type={handle_type}\")")
    H.append("            # Ensure point exists")
    H.append("            while len(curve.points) <= point_idx:")
    H.append("                curve.points.new(x, y)")
    H.append("                print(f\"[DEBUG] Created new point at index {len(curve.points)-1} with initial x={x}, y={y}\")")
    H.append("            point = curve.points[point_idx]")
    H.append("            print(f\"[DEBUG] Using point {point_idx}, total points: {len(curve.points)}\")")
    H.append("            # Set point data")
    H.append("            point.location = (x, y)")
    H.append("            point.handle_type = handle_type")
    H.append("            print(f\"[DEBUG] Set point location to {(x, y)}, handle_type to {handle_type}\")")
    H.append("            _BNDL_TOUCHED.add(token)")
    H.append("            return")
    H.append("        except Exception as ex:")
    H.append("            _warn(f\"Failed to set curve point on {getattr(n,'name',type(n).__name__)}.{key}: {ex}\")")
    H.append("            return")
    H.append("")
    H.append("    # --- Fall back to RNA property by UI name (ENUM/BOOLEAN/POINTER/numeric) ---")
    H.append("    try:")
    H.append("        import bpy")
    H.append("        # helper to unwrap our sentinel-wrapped names")
    H.append("        def _unwrap_sym(raw, sym):")
    H.append("            s = str(raw)")
    H.append("            return s[len(sym):-len(sym)] if s.startswith(sym) and s.endswith(sym) else None")
    H.append("")
    H.append("        for p in n.bl_rna.properties:")
    H.append("            if getattr(p, 'name', '') != key:")
    H.append("                continue")
    H.append("")
    H.append("            # ENUM ‚Üí set by UI label")
    H.append("            if p.type == 'ENUM':")
    H.append("                _set_enum_by_ui_label(n, p.identifier, str(val).strip('¬©'))")
    H.append("                return")
    H.append("")
    H.append("            # BOOLEAN ‚Üí bool")
    H.append("            if p.type == 'BOOLEAN':")
    H.append("                setattr(n, p.identifier, bool(_parse_value(val)))")
    H.append("                return")
    H.append("")
    H.append("            # POINTER ‚Üí look up/create datablock proxies by fixed_type")
    H.append("            if p.type == 'POINTER' and hasattr(p, 'fixed_type'):")
    H.append("                raw = str(val)")
    H.append("                T = p.fixed_type  # e.g. bpy.types.Image, Object, Material, Collection, Mesh, Curve")
    H.append("                name = (")
    H.append("                    _unwrap_sym(raw, '‚ú∑') or  # Image")
    H.append("                    _unwrap_sym(raw, '‚äû') or  # Object")
    H.append("                    _unwrap_sym(raw, '‚ùÜ') or  # Material")
    H.append("                    _unwrap_sym(raw, '‚ú∏') or  # Collection")
    H.append("                    _unwrap_sym(raw, '‚ßâ') or  # Mesh")
    H.append("                    _unwrap_sym(raw, 'ùíû') or  # Curve")
    H.append("                    str(_parse_value(val))")
    H.append("                )")
    H.append("")
    H.append("                try:")
    H.append("                    reuse = bool(globals().get('BNDL_REUSE_PROXIES', True))")
    H.append("                    proxy_name = f\"bndlproxy_{name}\" if name else 'bndlproxy'")
    H.append("                    if T is bpy.types.Image:")
    H.append('                        name = name.strip().strip(\"\\\'\")')
    H.append("                        name = name.strip('\\\"')")
    H.append("                        db = bpy.data.images.get(name)")
    H.append("                        if db is None and reuse:")
    H.append("                            db = bpy.data.images.get(proxy_name)")
    H.append("                        if db is None:")
    H.append("                            db = bpy.data.images.new(name=proxy_name, width=1, height=1)")
    H.append("                    elif T is bpy.types.Object:")
    H.append("                        db = bpy.data.objects.get(name)")
    H.append("                        if db is None and reuse:")
    H.append("                            db = bpy.data.objects.get(proxy_name)")
    H.append("                        if db is None:")
    H.append("                            db = bpy.data.objects.new(name=proxy_name, object_data=None)")
    H.append("                            try:")
    H.append("                                scene = bpy.context.scene")
    H.append("                                if scene:")
    H.append("                                    scene.collection.objects.link(db)")
    H.append("                            except Exception:")
    H.append("                                pass")
    H.append("                    elif T is bpy.types.Material:")
    H.append("                        db = bpy.data.materials.get(name)")
    H.append("                        if db is None and reuse:")
    H.append("                            db = bpy.data.materials.get(proxy_name)")
    H.append("                        if db is None:")
    H.append("                            db = bpy.data.materials.new(name=proxy_name)")
    H.append("                    elif T is bpy.types.Collection:")
    H.append("                        db = bpy.data.collections.get(name)")
    H.append("                        if db is None and reuse:")
    H.append("                            db = bpy.data.collections.get(proxy_name)")
    H.append("                        if db is None:")
    H.append("                            db = bpy.data.collections.new(name=proxy_name)")
    H.append("                            try:")
    H.append("                                scene = bpy.context.scene")
    H.append("                                if scene:")
    H.append("                                    scene.collection.children.link(db)")
    H.append("                            except Exception:")
    H.append("                                pass")
    H.append("                    elif T is bpy.types.Mesh:")
    H.append("                        db = bpy.data.meshes.get(name)")
    H.append("                        if db is None and reuse:")
    H.append("                            db = bpy.data.meshes.get(proxy_name)")
    H.append("                        if db is None:")
    H.append("                            db = bpy.data.meshes.new(name=proxy_name)")
    H.append("                    elif T is bpy.types.Curve:")
    H.append("                        db = bpy.data.curves.get(name)")
    H.append("                        if db is None and reuse:")
    H.append("                            db = bpy.data.curves.get(proxy_name)")
    H.append("                        if db is None:")
    H.append("                            db = bpy.data.curves.new(name=proxy_name, type='CURVE')")
    H.append("                    else:")
    H.append("                        db = None")
    H.append("                    setattr(n, p.identifier, db)")
    H.append("                    return")
    H.append("                except Exception:")
    H.append("                    pass")
    H.append("")
    H.append("            # Handle node color properties")
    H.append("            if key == 'use_custom_color':")
    H.append("                try:")
    H.append("                    setattr(n, 'use_custom_color', bool(val))")
    H.append("                    return")
    H.append("                except Exception:")
    H.append("                    pass")
    H.append("            if key == 'color':")
    H.append("                try:")
    H.append("                    if isinstance(val, (list, tuple)) and len(val) >= 3:")
    H.append("                        setattr(n, 'color', (float(val[0]), float(val[1]), float(val[2])))")
    H.append("                    return")
    H.append("                except Exception:")
    H.append("                    pass")
    H.append("")
    H.append("            # Fallback: numeric/tuple/string assignment")
    H.append("            try:")
    H.append("                setattr(n, p.identifier, _parse_value(val))")
    H.append("                return")
    H.append("            except Exception:")
    H.append("                return")
    H.append("    except Exception:")
    H.append("        pass")
    H.append("")
    H.append("    _warn(f\"Unapplied Set entry on {getattr(n,'name',type(n).__name__)}: '{key}' -> {val}\")")
    H.append("")

    H.append("def _display_names_for_sockets(sockets, is_inputs):")
    H.append("    base_alias = 'input' if is_inputs else 'output'")
    H.append("    counts = {}; names = []")
    H.append("    for s in sockets:")
    H.append("        nm = (getattr(s,'name','') or '').strip() or base_alias")
    H.append("        counts[nm] = counts.get(nm,0) + 1")
    H.append("        disp = nm if counts[nm]==1 else f\"{nm}[{counts[nm]}]\"")
    H.append("        names.append(disp)")
    H.append("    return names")
    H.append("")

    H.append("def _guess_socket_type(label):")
    H.append("    L = (label or '').strip().lower()")
    H.append("    # Exact matches first")
    H.append("    exact = {")
    H.append("        'curve': 'NodeSocketGeometry',")
    H.append("        'geometry': 'NodeSocketGeometry',")
    H.append("        'instance': 'NodeSocketGeometry',")
    H.append("        'instances': 'NodeSocketGeometry',")
    H.append("        'mesh': 'NodeSocketGeometry',")
    H.append("        'points': 'NodeSocketGeometry',")
    H.append("        'volume': 'NodeSocketGeometry',")

    H.append("        'as instance': 'NodeSocketBool',")
    H.append("        'bool': 'NodeSocketBool',")
    H.append("        'boolean': 'NodeSocketBool',")
    H.append("        'clamp factor': 'NodeSocketBool',")
    H.append("        'index mask': 'NodeSocketBool',")
    H.append("        'original': 'NodeSocketBool',")
    H.append("        'relative': 'NodeSocketBool',")
    H.append("        'replace radius': 'NodeSocketBool',")
    H.append("        'selection': 'NodeSocketBool',")

    H.append("        'count': 'NodeSocketInt',")
    H.append("        'id': 'NodeSocketInt',")
    H.append("        'index': 'NodeSocketInt',")
    H.append("        'int': 'NodeSocketInt',")
    H.append("        'integer': 'NodeSocketInt',")
    H.append("        'iterations': 'NodeSocketInt',")
    H.append("        'seed': 'NodeSocketInt',")

    H.append("        'alpha': 'NodeSocketFloat',")
    H.append("        'angle': 'NodeSocketFloat',")
    H.append("        'delta time': 'NodeSocketFloat',")
    H.append("        'distance': 'NodeSocketFloat',")
    H.append("        'factor': 'NodeSocketFloat',")
    H.append("        'factor max': 'NodeSocketFloat',")
    H.append("        'factor min': 'NodeSocketFloat',")
    H.append("        'length': 'NodeSocketFloat',")
    H.append("        'max': 'NodeSocketFloat',")
    H.append("        'min': 'NodeSocketFloat',")
    H.append("        'offset': 'NodeSocketFloat',")
    H.append("        'radius': 'NodeSocketFloat',")
    H.append("        'scale': 'NodeSocketFloat',")
    H.append("        'scale x': 'NodeSocketFloat',")
    H.append("        'scale y': 'NodeSocketFloat',")
    H.append("        'scale z': 'NodeSocketFloat',")
    H.append("        'shape': 'NodeSocketFloat',")
    H.append("        'size': 'NodeSocketFloat',")
    H.append("        'strength': 'NodeSocketFloat',")
    H.append("        'value': 'NodeSocketFloat',")
    H.append("        'weight': 'NodeSocketFloat',")
    H.append("        'x': 'NodeSocketFloat',")
    H.append("        'y': 'NodeSocketFloat',")
    H.append("        'z': 'NodeSocketFloat',")

    H.append("        'direction': 'NodeSocketVector',")
    H.append("        'location': 'NodeSocketVector',")
    H.append("        'normal': 'NodeSocketVector',")
    H.append("        'position': 'NodeSocketVector',")
    H.append("        'resolution': 'NodeSocketVector',")
    H.append("        'rotation': 'NodeSocketVector',")
    H.append("        'tangent': 'NodeSocketVector',")
    H.append("        'vector': 'NodeSocketVector',")

    H.append("        'base color': 'NodeSocketColor',")
    H.append("        'color': 'NodeSocketColor',")
    H.append("        'rgba': 'NodeSocketColor',")

    H.append("        'domain': 'NodeSocketString',")
    H.append("        'name': 'NodeSocketString',")
    H.append("        'string': 'NodeSocketString',")
    H.append("        'uv map': 'NodeSocketString',")

    H.append("        'collection': 'NodeSocketCollection',")
    H.append("        'image': 'NodeSocketImage',")
    H.append("        'material': 'NodeSocketMaterial',")
    H.append("        'object': 'NodeSocketObject',")
    H.append("        'texture': 'NodeSocketTexture',")

    H.append("        'float_angle': 'NodeSocketFloatAngle',")
    H.append("        'float_distance': 'NodeSocketFloatDistance',")
    H.append("        'float_factor': 'NodeSocketFloatFactor',")
    H.append("        'float_percentage': 'NodeSocketFloatPercentage',")
    H.append("        'float_time': 'NodeSocketFloatTime',")
    H.append("        'float_time_absolute': 'NodeSocketFloatTimeAbsolute',")
    H.append("        'float_unsigned': 'NodeSocketFloatUnsigned',")
    H.append("        'int_factor': 'NodeSocketIntFactor',")
    H.append("        'int_percentage': 'NodeSocketIntPercentage',")
    H.append("        'int_unsigned': 'NodeSocketIntUnsigned',")
    H.append("        'matrix': 'NodeSocketMatrix',")
    H.append("        'menu': 'NodeSocketMenu',")
    H.append("        'shader': 'NodeSocketShader',")
    H.append("        'vector_acceleration': 'NodeSocketVectorAcceleration',")
    H.append("        'vector_direction': 'NodeSocketVectorDirection',")
    H.append("        'vector_euler': 'NodeSocketVectorEuler',")
    H.append("        'vector_euler_4d': 'NodeSocketVectorEuler4D',")
    H.append("        'vector_translation': 'NodeSocketVectorTranslation',")
    H.append("        'vector_translation_4d': 'NodeSocketVectorTranslation4D',")
    H.append("        'vector_velocity': 'NodeSocketVectorVelocity',")
    H.append("        'vector_xyz': 'NodeSocketVectorXYZ',")
    H.append("        'vector_xyz_4d': 'NodeSocketVectorXYZ4D',")
    H.append("    }")

    H.append("    if L in exact: return exact[L]")
    H.append("    # Heuristics by substring")
    H.append("    if any(k in L for k in ('geom','mesh','curve','point','instanc')): return 'NodeSocketGeometry'")
    H.append("    if any(k in L for k in ('bool','select','enabled','use ', 'enable ')): return 'NodeSocketBool'")
    H.append("    if any(k in L for k in ('index','count','iterations')): return 'NodeSocketInt'")
    H.append("    if any(k in L for k in ('value','factor','radius','scale','min','max','size','length','weight','strength','threshold','offset','angle','seed')):")
    H.append("        return 'NodeSocketFloat'")
    H.append("    if any(k in L for k in ('vec','direction','normal','tangent','axis')): return 'NodeSocketVector'")
    H.append("    if 'color' in L: return 'NodeSocketColor'")
    H.append("    if 'material' in L: return 'NodeSocketMaterial'")
    H.append("    if 'object' in L: return 'NodeSocketObject'")
    H.append("    # Default")
    H.append("    return 'NodeSocketGeometry'")
    H.append("")

    H.append("def _infer_interface_ports(steps):")
    H.append("    \"\"\"Infer Group Input/Output interface sockets from Connect steps when 'declare' is absent.")
    H.append("    Returns (gi_ports, go_ports) as lists of (name, socket_type).\"\"\"")
    H.append("    gi = []  # outputs on Group Input")
    H.append("    go = []  # inputs on Group Output")
    H.append("    seen_gi = set()")
    H.append("    seen_go = set()")
    H.append("    for st in steps:")
    H.append("        if st.get('kind') != 'connect':")
    H.append("            continue")
    H.append("        fr = st.get('from', {})")
    H.append("        if fr and fr.get('ui_type') == 'Group Input':")
    H.append("            nm = str(st.get('from_port', '')).strip()")
    H.append("            if nm and nm not in seen_gi:")
    H.append("                gi.append((nm, _guess_socket_type(nm)))")
    H.append("                seen_gi.add(nm)")
    H.append("        to = st.get('to', {})")
    H.append("        if to and to.get('ui_type') == 'Group Output':")
    H.append("            nm = str(st.get('to_port', '')).strip()")
    H.append("            if nm and nm not in seen_go:")
    H.append("                go.append((nm, _guess_socket_type(nm)))")
    H.append("                seen_go.add(nm)")
    H.append("    return gi, go")
    H.append("")

    H.append("def rebuild_interface(ng, gi_ports, go_ports):")
    H.append("    iface = ng.interface")
    H.append("    iface.clear()")
    H.append("    print(f\"[DEBUG] Rebuilding interface: gi_ports={gi_ports}, go_ports={go_ports}\")")
    H.append("    for nm, st in gi_ports:")
    H.append("        iface.new_socket(name=nm, in_out='INPUT', socket_type=st)")
    H.append("    for nm, st in go_ports:")
    H.append("        iface.new_socket(name=nm, in_out='OUTPUT', socket_type=st)")
    H.append("")

    H.append("def resolve_socket_by_display(node, side, display):")
    H.append("    # Strict socket resolution. If no match, return None and warn (no guessing/index-0 fallback).")
    H.append("    import re")
    H.append("    print(f\"[DEBUG] resolve_socket_by_display: node={getattr(node,'name','?')}, side={side}, wanted={display}\")")
    H.append("    nt = node.id_data")
    H.append("    is_group_in  = node.bl_idname in {'NodeGroupInput','GeometryNodeGroupInput'}")
    H.append("    is_group_out = node.bl_idname in {'NodeGroupOutput','GeometryNodeGroupOutput'}")
    H.append("    coll = node.inputs if side=='in' else node.outputs")
    H.append("    wanted = (display or '').strip()")
    H.append("")
    H.append("    def _warn_missing():")
    H.append("        _warn(f\"Socket '{wanted}' not found on {getattr(node, 'name', type(node).__name__)} ({'inputs' if side=='in' else 'outputs'}).\")")
    H.append("")
    H.append("    def match_in_collection(sock_list):")
    H.append("        # 1) direct visible name - REMOVED .get() shortcut to ensure we check is_linked")
    H.append("        # if hasattr(sock_list,'get'):")
    H.append("        #    s = sock_list.get(wanted, None)")
    H.append("        #    if s is not None: return s")
    H.append("")
    H.append("        # 2) Case N  ‚Üí  map to 0-based ordinal commonly used by Index Switch exports")
    H.append("        m = re.match(r'^Case\\s+(\\d+)$', wanted, flags=re.I)")
    H.append("        if m:")
    H.append("            idx = int(m.group(1)) - 1")
    H.append("            return sock_list[idx] if 0 <= idx < len(sock_list) else None")
    H.append("")

    H.append("        # 2b) Pure number ‚Üí positional input index")
    H.append("        # If the first input is literally named 'Index', treat numbers as case-slots and offset by +1.")
    H.append("        m = re.match(r'^(\\d+)$', wanted)")
    H.append("        if m:")
    H.append("            idx = int(m.group(1))")
    H.append("            try:")
    H.append("                first_nm = (getattr(sock_list[0], 'name', '') or '').strip()")
    H.append("            except Exception:")
    H.append("                first_nm = ''")
    H.append("            pos = idx + 1 if first_nm == 'Index' else idx")
    H.append("            return sock_list[pos] if 0 <= pos < len(sock_list) else None")

    H.append("")
    H.append("        # 3) Name[n] ‚Üí nth socket with same base name")
    H.append("        m = re.match(r'^(.+?)\\[(\\d+)\\]$', wanted)")
    H.append("        if m:")
    H.append("            base, nth = m.group(1), int(m.group(2)); count = 0")
    H.append("            for sock in sock_list:")
    H.append("                nm = (getattr(sock,'name','') or '').strip() or ('input' if side=='in' else 'output')")
    H.append("                if nm == base:")
    H.append("                    count += 1")
    H.append("                    if count == nth: return sock")
    H.append("        # 4) alias input/output (optional [n])")
    H.append("        m = re.match(r'^(input|output)(?:\\[(\\d+)\\])?$', wanted, flags=re.I)")
    H.append("        if m:")
    H.append("            idx = (int(m.group(2))-1) if m.group(2) else 0")
    H.append("            return sock_list[idx] if 0 <= idx < len(sock_list) else None")
    H.append("")
    H.append("        # 5) bare base-name - if multiple sockets have the same name, find the first unlinked one")
    H.append("        candidates = []")
    H.append("        for sock in sock_list:")
    H.append("            nm = (getattr(sock,'name','') or '').strip() or ('input' if side=='in' else 'output')")
    H.append("            if nm == wanted:")
    H.append("                candidates.append(sock)")
    H.append("        ")
    H.append("        # If we found candidates")
    H.append("        if candidates:")
    H.append("            # Debug candidates")
    H.append("            cand_info = [f\"{getattr(c,'name','?')} (linked={c.is_linked})\" for c in candidates]")
    H.append("            print(f\"[DEBUG] Candidates for '{wanted}': {cand_info}\")")
    H.append("")
    H.append("            # If only one candidate, return it")
    H.append("            if len(candidates) == 1:")
    H.append("                return candidates[0]")
    H.append("            # If multiple candidates with same name, prefer unlinked ones")
    H.append("            for sock in candidates:")
    H.append("                if not sock.is_linked:")
    H.append("                    return sock")
    H.append("            # If all are linked, return the first one")
    H.append("            return candidates[0]")
    H.append("        ")
    H.append("        _warn_missing()")
    H.append("        return None")
    H.append("")
    H.append("    # Non-group nodes: strict matching")
    H.append("    if not (is_group_in or is_group_out):")
    H.append("        return match_in_collection(coll)")
    H.append("")
    H.append("    # Group Input: outputs mirror interface INPUTS; matching against node.outputs is fine")
    H.append("    if is_group_in and side=='out':")
    H.append("        return match_in_collection(node.outputs)")
    H.append("")
    H.append("    # Group Output: filter admin inputs, then match strictly")
    H.append("    if is_group_out and side=='in':")
    H.append("        ADMIN = {'Warning Propagation','Show Preview','Show Texture','Icon','Active Output'}")
    H.append("        iface_inputs = [s for s in node.inputs if (getattr(s,'name','') or '').strip() not in ADMIN]")
    H.append("        class _Seq:")
    H.append("            def __init__(self, seq): self._seq = list(seq)")
    H.append("            def __iter__(self): return iter(self._seq)")
    H.append("            def __len__(self): return len(self._seq)")
    H.append("            def __getitem__(self,i): return self._seq[i]")
    H.append("            def get(self, key, default=None):")
    H.append("                for s in self._seq:")
    H.append("                    nm = (getattr(s,'name','') or '').strip()")
    H.append("                    if nm == key or nm.lower() == key.lower(): return s")
    H.append("                return default")
    H.append("        return match_in_collection(_Seq(iface_inputs))")
    H.append("")
    H.append("    # Any other case: strict on the provided collection")
    H.append("    return match_in_collection(coll)")
    H.append("")


    H.append("def _iface_type_for_socket(sock):")
    H.append("    # Determine a NodeSocket* idname suitable for ng.interface from a real socket object.")
    H.append("    if sock is None: return 'NodeSocketFloat'")
    H.append("    # Prefer explicit idname on the socket; otherwise fall back to class name.")
    H.append("    bid = (getattr(sock, 'bl_socket_idname', '') or '').lower()")
    H.append("    if not bid:")
    H.append("        bid = (getattr(type(sock), '__name__', '') or '').lower()")
    H.append("    # Direct map by known fragments")
    H.append("    tbl = {")
    H.append("        'nodesocketgeometry':'NodeSocketGeometry',")
    H.append("        'nodesocketfloat':'NodeSocketFloat',")
    H.append("        'nodesocketint':'NodeSocketInt',")
    H.append("        'nodesocketbool':'NodeSocketBool',")
    H.append("        'nodesocketvector':'NodeSocketVector',")
    H.append("        'nodesocketcolor':'NodeSocketColor',")
    H.append("        'nodesocketrotation':'NodeSocketRotation',")
    H.append("        'nodesocketstring':'NodeSocketString',")
    H.append("        'nodesocketmatrix':'NodeSocketMatrix',")
    H.append("        'nodesocketcollection':'NodeSocketCollection',")
    H.append("        'nodesocketimage':'NodeSocketImage',")
    H.append("        'nodesocketmaterial':'NodeSocketMaterial',")
    H.append("        'nodesocketobject':'NodeSocketObject',")
    H.append("        'nodesockettexture':'NodeSocketTexture',")
    H.append("        'nodesocketmenu':'NodeSocketMenu',")
    H.append("    }")
    H.append("    for k, v in tbl.items():")
    H.append("        if k in bid: return v")
    H.append("    # Heuristic by default_value type/shape if present (helps when idname is missing)")
    H.append("    try:")
    H.append("        dv = getattr(sock, 'default_value', None)")
    H.append("        if isinstance(dv, bool): return 'NodeSocketBool'")
    H.append("        if isinstance(dv, int): return 'NodeSocketInt'")
    H.append("        # floats come before tuples to avoid treating scalar as iterable")
    H.append("        if isinstance(dv, float): return 'NodeSocketFloat'")
    H.append("        if isinstance(dv, (tuple, list)):")
    H.append("            ln = len(dv)")
    H.append("            if ln == 3: return 'NodeSocketVector'")
    H.append("            if ln == 4: return 'NodeSocketColor'")
    H.append("    except Exception:")
    H.append("        pass")
    H.append("    # Safer default than hard-coding Geometry: Float is least surprising")
    H.append("    return 'NodeSocketFloat'")

    H.append("def _norm_port(label):")
    H.append("    \"\"\"Strip bracketed numeric suffixes like 'B[3]' ‚Üí 'B' for display-name matching.\"\"\"")
    H.append("    try:")
    H.append("        s = str(label).strip()")
    H.append("        i = s.find('[')")
    H.append("        return s[:i] if i > 0 else s")
    H.append("    except Exception:")
    H.append("        return str(label)")

    H.append("def _infer_interface_ports_from_graph(nt, idmap, steps):")
    H.append("    \"\"\"Infer GI/GO interface ports by peeking at the *other* end of each Connect.")
    H.append("    Returns (gi_ports, go_ports) as lists of (name, socket_type).\"\"\"")
    H.append("    gi = []; go = []")
    H.append("    seen_gi = set(); seen_go = set()")
    H.append("    for st in steps:")
    H.append("        if st.get('kind') != 'connect':")
    H.append("            continue")
    H.append("        fr = st.get('from', {}); to = st.get('to', {})")
    H.append("        # Group Input ‚Üí something: type is the destination input's socket type")
    H.append("        if fr and fr.get('ui_type') == 'Group Input':")
    H.append("            nm = str(st.get('from_port','')).strip()")
    H.append("            try:")
    H.append("                dn = idmap.get((to['ui_type'], to.get('inst') or ''))")

    H.append("                raw = st.get('to_port','')")
    H.append("                ts = resolve_socket_by_display(dn, 'in', raw) or resolve_socket_by_display(dn, 'in', _norm_port(raw)) if dn else None")

    H.append("                stype = _iface_type_for_socket(ts) if ts else None")
    H.append("            except Exception:")
    H.append("                stype = None")
    H.append("            if nm and nm not in seen_gi and stype:")
    H.append("                gi.append((nm, stype)); seen_gi.add(nm)")
    H.append("        # something ‚Üí Group Output: type is the source output's socket type")
    H.append("        if to and to.get('ui_type') == 'Group Output':")
    H.append("            nm = str(st.get('to_port','')).strip()")
    H.append("            try:")
    H.append("                sn = idmap.get((fr['ui_type'], fr.get('inst') or ''))")

    H.append("                raw = st.get('from_port','')")
    H.append("                fs = resolve_socket_by_display(sn, 'out', raw) or resolve_socket_by_display(sn, 'out', _norm_port(raw)) if sn else None")

    H.append("                stype = _iface_type_for_socket(fs) if fs else None")
    H.append("            except Exception:")
    H.append("                stype = None")
    H.append("            if nm and nm not in seen_go and stype:")
    H.append("                go.append((nm, stype)); seen_go.add(nm)")
    H.append("    return gi, go")
    H.append("")

    H.append("# --- Link helper that inserts converters for mismatched socket types ---")
    H.append("def _new_link_with_convert(nt, fs, ts):")
    H.append("    def _kind(sock):")
    H.append("        # Prefer bl_socket_idname (stable across node trees), then .type")
    H.append("        bid = (getattr(sock, 'bl_socket_idname', '') or '').lower()")
    H.append("        typ = (getattr(sock, 'type', '') or '').upper()")
    H.append("        # Map by idname first")
    H.append("        if 'nodesocketgeometry' in bid: return 'GEOMETRY'")
    H.append("        if 'nodesocketvector'   in bid: return 'VECTOR'")
    H.append("        if 'nodesocketfloat'    in bid: return 'VALUE'")
    H.append("        if 'nodesocketint'      in bid: return 'INT'")
    H.append("        if 'nodesocketbool'     in bid: return 'BOOLEAN'")
    H.append("        if 'nodesocketcolor'    in bid: return 'RGBA'")
    H.append("        if 'nodesocketstring'   in bid: return 'STRING'")
    H.append("        # Fall back to .type used by Blender")
    H.append("        if typ in {'GEOMETRY','VECTOR','VALUE','INT','BOOLEAN','RGBA','STRING'}: return typ")
    H.append("        # Last resort: try name hints")
    H.append("        nm = (getattr(sock,'name','') or '').lower()")
    H.append("        if any(k in nm for k in ('color','rgba')): return 'RGBA'")
    H.append("        if any(k in nm for k in ('vector','x','y','z')): return 'VECTOR'")
    H.append("        return typ or bid or 'UNKNOWN'")
    H.append("")
    H.append("    try:")
    H.append("        ft = _kind(fs)")
    H.append("        tt = _kind(ts)")
    H.append("        # If types already match, just link.")
    H.append("        if ft == tt:")
    H.append("            nt.links.new(fs, ts)")
    H.append("            return True")
    H.append("")

    H.append("        # === VECTOR ‚Üí VALUE : X/Y/Z sockets via Separate XYZ; otherwise Vector Length ===")
    H.append("        if ft == 'VECTOR' and tt == 'VALUE':")
    H.append("            dest_name = (getattr(ts, 'name','') or '').strip().upper()")
    H.append("            if dest_name in {'X','Y','Z'}:")
    H.append("                try: sep = nt.nodes.new('FunctionNodeSeparateXYZ')")
    H.append("                except Exception: sep = nt.nodes.new('ShaderNodeSeparateXYZ')")
    H.append("                try: nt.links.new(fs, sep.inputs.get('Vector'))")
    H.append("                except Exception: nt.nodes.remove(sep); return False")
    H.append("                try:")
    H.append("                    out = sep.outputs.get(dest_name) or sep.outputs[{ 'X':0, 'Y':1, 'Z':2 }[dest_name]]")
    H.append("                    nt.links.new(out, ts)")
    H.append("                except Exception: nt.nodes.remove(sep); return False")
    H.append("                return True")
    H.append("            n = nt.nodes.new('ShaderNodeVectorMath')")
    H.append("            n.operation = 'LENGTH'")
    H.append("            try: nt.links.new(fs, n.inputs.get('Vector'))")
    H.append("            except Exception: nt.nodes.remove(n); return False")
    H.append("            try: nt.links.new(n.outputs.get('Value'), ts)")
    H.append("            except Exception: nt.nodes.remove(n); return False")
    H.append("            return True")

    H.append("")
    H.append("            # 2) If the source is Combine XYZ and the destination is a generic/numbered float")
    H.append("            #    prefer the X channel (matches your 1.0 / 1.5 case inputs).")
    H.append("            try: src_blid = getattr(src_node, 'bl_idname', '')")
    H.append("            except Exception: src_blid = ''")
    H.append("            if src_blid in {'ShaderNodeCombineXYZ','FunctionNodeCombineXYZ'}:")
    H.append("                try: sep = nt.nodes.new('FunctionNodeSeparateXYZ')")
    H.append("                except Exception: sep = nt.nodes.new('ShaderNodeSeparateXYZ')")

    H.append("                try: nt.links.new(fs, sep.inputs.get('Vector'))")
    H.append("                except Exception: nt.nodes.remove(sep); return False")
    H.append("                try:")
    H.append("                    nt.links.new(sep.outputs.get('X'), ts)")
    H.append("                except Exception: nt.nodes.remove(sep); return False")
    H.append("                return True")
    H.append("")
    H.append("            # 3) Fallback: magnitude via Vector Math (Length)")
    H.append("            n = nt.nodes.new('ShaderNodeVectorMath')")
    H.append("            n.operation = 'LENGTH'")
    H.append("            try: nt.links.new(fs, n.inputs.get('Vector'))")
    H.append("            except Exception: nt.nodes.remove(n); return False")
    H.append("            try: nt.links.new(n.outputs.get('Value'), ts)")
    H.append("            except Exception: nt.nodes.remove(n); return False")
    H.append("            return True")


    H.append("")
    H.append("        # === VECTOR ‚Üí RGBA : Separate XYZ, then Combine Color ===")
    H.append("        if ft == 'VECTOR' and tt == 'RGBA':")
    H.append("            try: sep = nt.nodes.new('FunctionNodeSeparateXYZ')")
    H.append("            except Exception: sep = nt.nodes.new('ShaderNodeSeparateXYZ')")
    H.append("            try:")
    H.append("                com = nt.nodes.new('FunctionNodeCombineColor')")
    H.append("            except Exception:")
    H.append("                com = nt.nodes.new('ShaderNodeCombineRGB')")
    H.append("            try: nt.links.new(fs, sep.inputs.get('Vector'))")
    H.append("            except Exception: nt.nodes.remove(sep); nt.nodes.remove(com); return False")
    H.append("            try:")
    H.append("                nt.links.new(sep.outputs.get('X'), com.inputs.get('R') or com.inputs.get('Red'))")
    H.append("                nt.links.new(sep.outputs.get('Y'), com.inputs.get('G') or com.inputs.get('Green'))")
    H.append("                nt.links.new(sep.outputs.get('Z'), com.inputs.get('B') or com.inputs.get('Blue'))")
    H.append("                out_col = com.outputs.get('Color') or com.outputs.get('Image')")
    H.append("                nt.links.new(out_col, ts)")
    H.append("            except Exception: nt.nodes.remove(sep); nt.nodes.remove(com); return False")
    H.append("            return True")
    H.append("")
    H.append("        # === VALUE ‚Üí BOOLEAN : Compare (Not Equal 0) ===")
    H.append("        if ft == 'VALUE' and tt == 'BOOLEAN':")
    H.append("            cmp = nt.nodes.new('FunctionNodeCompare')")
    H.append("            try: cmp.data_type = 'FLOAT'")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(fs, cmp.inputs.get('A'))")
    H.append("            except Exception: nt.nodes.remove(cmp); return False")
    H.append("            try:")
    H.append("                cmp.inputs.get('B').default_value = 0.0")
    H.append("                cmp.operation = 'NOT_EQUAL'")
    H.append("                nt.links.new(cmp.outputs.get('Result'), ts)")
    H.append("            except Exception: nt.nodes.remove(cmp); return False")
    H.append("            return True")
    H.append("")
    H.append("        # === BOOLEAN ‚Üí VALUE : Switch(Float) (True‚Üí1, False‚Üí0) ===")
    H.append("        if ft == 'BOOLEAN' and tt == 'VALUE':")
    H.append("            sw = nt.nodes.new('FunctionNodeSwitch')")
    H.append("            try: sw.input_type = 'FLOAT'")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(fs, sw.inputs.get('Switch'))")
    H.append("            except Exception: nt.nodes.remove(sw); return False")
    H.append("            try:")
    H.append("                sw.inputs.get('False').default_value = 0.0")
    H.append("                sw.inputs.get('True').default_value  = 1.0")
    H.append("                nt.links.new(sw.outputs.get('Output'), ts)")
    H.append("            except Exception: nt.nodes.remove(sw); return False")
    H.append("            return True")

    H.append("        # === ADDITIONAL IMPLICIT‚ÜíEXPLICIT CASES ===")
    H.append("")
    H.append("        # FLOAT ‚Üí VECTOR : replicate scalar across XYZ via Combine XYZ")
    H.append("        if ('Float' in sid) and ('Vector' in tid):")
    H.append("            try:")
    H.append("                comb = nt.nodes.new('FunctionNodeCombineXYZ')")
    H.append("            except Exception:")
    H.append("                comb = nt.nodes.new('ShaderNodeCombineXYZ')")
    H.append("            try:")
    H.append("                sx, sy = getattr(sa.node, 'location', (0,0)); dx, dy = getattr(sb.node, 'location', (0,0))")
    H.append("                comb.location = ((sx+dx)*0.5 + 40, (sy+dy)*0.5)")
    H.append("            except Exception: pass")
    H.append("            # feed same scalar to X/Y/Z")
    H.append("            for nm in ('X','Y','Z'):")
    H.append("                try: nt.links.new(sa, comb.inputs.get(nm))")
    H.append("                except Exception: pass")
    H.append("            try: nt.links.new(comb.outputs.get('Vector', comb.outputs[0]), sb); return True")
    H.append("            except Exception: return False")
    H.append("")
    H.append("        # VECTOR ‚Üí COLOR : pack XYZ into RGB (A left at default 1)")
    H.append("        if ('Vector' in sid) and ('Color' in tid):")
    H.append("            # split vector via cached Separate XYZ")
    H.append("            sep = _get_sep_xyz(nt, sa, getattr(sb, 'node', None))")
    H.append("            # combine to color")
    H.append("            try:")
    H.append("                comc = nt.nodes.new('FunctionNodeCombineColor')")
    H.append("            except Exception:")
    H.append("                comc = nt.nodes.new('ShaderNodeCombineRGB')")
    H.append("            try:")
    H.append("                sx, sy = getattr(sa.node, 'location', (0,0)); dx, dy = getattr(sb.node, 'location', (0,0))")
    H.append("                comc.location = ((sx+dx)*0.5 + 40, (sy+dy)*0.5)")
    H.append("            except Exception: pass")
    H.append("            for vnm, cnm in (('X','Red'), ('Y','Green'), ('Z','Blue')):")
    H.append("                try: nt.links.new(sep.outputs.get(vnm), comc.inputs.get(cnm))")
    H.append("                except Exception: pass")
    H.append("            try: nt.links.new(comc.outputs.get('Color') or comc.outputs.get('Image'), sb); return True")
    H.append("            except Exception: return False")
    H.append("")
    H.append("        # COLOR ‚Üí FLOAT : route a single channel via Separate Color when target socket is R/G/B")
    H.append("        if ('Color' in sid) and ('Float' in tid) and dn in {'R','G','B','Red','Green','Blue'}:")
    H.append("            try:")
    H.append("                sepcol = nt.nodes.new('FunctionNodeSeparateColor')")
    H.append("            except Exception:")
    H.append("                sepcol = nt.nodes.new('ShaderNodeSeparateRGB')")
    H.append("            try:")
    H.append("                sx, sy = getattr(sa.node, 'location', (0,0)); dx, dy = getattr(sb.node, 'location', (0,0))")
    H.append("                sepcol.location = ((sx+dx)*0.5 - 40, (sy+dy)*0.5)")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(sa, sepcol.inputs.get('Color', sepcol.inputs[0]))")
    H.append("            except Exception: pass")
    H.append("            ch = {'R':'Red','G':'Green','B':'Blue','Red':'Red','Green':'Green','Blue':'Blue'}[dn]")
    H.append("            out = sepcol.outputs.get(ch) or sepcol.outputs[{'Red':0,'Green':1,'Blue':2}[ch]]")
    H.append("            try: nt.links.new(out, sb); return True")
    H.append("            except Exception: return False")
    H.append("")
    H.append("        # FLOAT ‚Üí INT/INDEX : explicit Float‚ÜíInteger cast node")
    H.append("        if ('Float' in sid) and ('Int' in tid or dn in {'Index','INT','Int'}):")
    H.append("            try: f2i = nt.nodes.new('FunctionNodeFloatToInt')")
    H.append("            except Exception: f2i = nt.nodes.new('FunctionNodeFloatToInt')")
    H.append("            try:")
    H.append("                sx, sy = getattr(sa.node, 'location', (0,0)); dx, dy = getattr(sb.node, 'location', (0,0))")
    H.append("                f2i.location = ((sx+dx)*0.5, (sy+dy)*0.5)")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(sa, f2i.inputs.get('Float', f2i.inputs[0]))")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(f2i.outputs.get('Integer', f2i.outputs[0]), sb); return True")
    H.append("            except Exception: return False")

    H.append("        # === ADDITIONAL IMPLICIT‚ÜíEXPLICIT CASES (GN 4.x) ===")

    H.append("        # FLOAT ‚Üí VECTOR : replicate scalar across X,Y,Z via Combine XYZ")
    H.append("        if ('Float' in sid) and ('Vector' in tid):")
    H.append("            try: comb = nt.nodes.new('FunctionNodeCombineXYZ')")
    H.append("            except Exception: comb = nt.nodes.new('ShaderNodeCombineXYZ')")
    H.append("            try:")
    H.append("                sx, sy = getattr(sa.node, 'location', (0,0)); dx, dy = getattr(sb.node, 'location', (0,0))")
    H.append("                comb.location = ((sx+dx)*0.5 + 40, (sy+dy)*0.5)")
    H.append("            except Exception: pass")
    H.append("            for nm in ('X','Y','Z'):")
    H.append("                try: nt.links.new(sa, comb.inputs.get(nm))")
    H.append("                except Exception: pass")
    H.append("            try: nt.links.new(comb.outputs.get('Vector', comb.outputs[0]), sb); return True")
    H.append("            except Exception: return False")
    H.append("")

    H.append("        # VECTOR ‚Üí COLOR : map XYZ to R,G,B (A left at default 1)")
    H.append("        if ('Vector' in sid) and ('Color' in tid):")
    H.append("            sep = _get_sep_xyz(nt, sa, getattr(sb, 'node', None))")
    H.append("            try: comc = nt.nodes.new('FunctionNodeCombineColor')")
    H.append("            except Exception: comc = nt.nodes.new('ShaderNodeCombineRGB')")
    H.append("            try:")
    H.append("                sx, sy = getattr(sa.node, 'location', (0,0)); dx, dy = getattr(sb.node, 'location', (0,0))")
    H.append("                comc.location = ((sx+dx)*0.5 + 40, (sy+dy)*0.5)")
    H.append("            except Exception: pass")
    H.append("            for vnm, cnm in (('X','Red'), ('Y','Green'), ('Z','Blue')):")
    H.append("                try: nt.links.new(sep.outputs.get(vnm), comc.inputs.get(cnm))")
    H.append("                except Exception: pass")
    H.append("            try: nt.links.new(comc.outputs.get('Color') or comc.outputs.get('Image'), sb); return True")
    H.append("            except Exception: return False")
    H.append("")

    H.append("        # COLOR ‚Üí VECTOR : map R,G,B to X,Y,Z")
    H.append("        if ('Color' in sid) and ('Vector' in tid):")
    H.append("            try: sepcol = nt.nodes.new('FunctionNodeSeparateColor')")
    H.append("            except Exception: sepcol = nt.nodes.new('ShaderNodeSeparateRGB')")
    H.append("            try: comb = nt.nodes.new('FunctionNodeCombineXYZ')")
    H.append("            except Exception: comb = nt.nodes.new('ShaderNodeCombineXYZ')")
    H.append("            try: nt.links.new(sa, sepcol.inputs.get('Color', sepcol.inputs[0]))")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(sepcol.outputs.get('Red') or sepcol.outputs.get('R'), comb.inputs.get('X'))")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(sepcol.outputs.get('Green') or sepcol.outputs.get('G'), comb.inputs.get('Y'))")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(sepcol.outputs.get('Blue') or sepcol.outputs.get('B'), comb.inputs.get('Z'))")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(comb.outputs.get('Vector', comb.outputs[0]), sb); return True")
    H.append("            except Exception: return False")
    H.append("")

    H.append("        # COLOR ‚Üí FLOAT : route single channel when target is R/G/B")
    H.append("        if ('Color' in sid) and ('Float' in tid) and dn in {'R','G','B','Red','Green','Blue'}:")
    H.append("            try: sepcol = nt.nodes.new('FunctionNodeSeparateColor')")
    H.append("            except Exception: sepcol = nt.nodes.new('ShaderNodeSeparateRGB')")
    H.append("            try:")
    H.append("                sx, sy = getattr(sa.node, 'location', (0,0)); dx, dy = getattr(sb.node, 'location', (0,0))")
    H.append("                sepcol.location = ((sx+dx)*0.5 - 40, (sy+dy)*0.5)")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(sa, sepcol.inputs.get('Color', sepcol.inputs[0]))")
    H.append("            except Exception: pass")
    H.append("            ch = {'R':'Red','G':'Green','B':'Blue','Red':'Red','Green':'Green','Blue':'Blue'}[dn]")
    H.append("            out = sepcol.outputs.get(ch) or sepcol.outputs[{'Red':0,'Green':1,'Blue':2}[ch]]")
    H.append("            try: nt.links.new(out, sb); return True")
    H.append("            except Exception: return False")
    H.append("")

    H.append("        # FLOAT ‚Üí COLOR : gray RGB from scalar, Alpha = 1")
    H.append("        if ('Float' in sid) and ('Color' in tid):")
    H.append("            try: comc = nt.nodes.new('FunctionNodeCombineColor')")
    H.append("            except Exception: comc = nt.nodes.new('ShaderNodeCombineRGB')")
    H.append("            try:")
    H.append("                sx, sy = getattr(sa.node, 'location', (0,0)); dx, dy = getattr(sb.node, 'location', (0,0))")
    H.append("                comc.location = ((sx+dx)*0.5 + 40, (sy+dy)*0.5)")
    H.append("            except Exception: pass")
    H.append("            for nm in ('Red','Green','Blue'):")
    H.append("                try: nt.links.new(sa, comc.inputs.get(nm))")
    H.append("                except Exception: pass")
    H.append("            try:")
    H.append("                a = comc.inputs.get('Alpha')")
    H.append("                if a is not None: a.default_value = 1.0")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(comc.outputs.get('Color') or comc.outputs.get('Image'), sb); return True")
    H.append("            except Exception: return False")
    H.append("")

    H.append("        # FLOAT ‚Üí BOOLEAN : Compare(A > 0.0)")
    H.append("        if ('Float' in sid) and ('Boolean' in tid):")
    H.append("            try: cmpn = nt.nodes.new('FunctionNodeCompare')")
    H.append("            except Exception: cmpn = nt.nodes.new('FunctionNodeCompare')")
    H.append("            try: cmpn.data_type = 'FLOAT'")
    H.append("            except Exception: pass")
    H.append("            try: cmpn.operation = 'GREATER_THAN'")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(sa, cmpn.inputs.get('A', cmpn.inputs[0]))")
    H.append("            except Exception: pass")
    H.append("            try:")
    H.append("                b = cmpn.inputs.get('B')")
    H.append("                if b is not None: b.default_value = 0.0")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(cmpn.outputs.get('Result') or cmpn.outputs[0], sb); return True")
    H.append("            except Exception: return False")
    H.append("")

    H.append("        # BOOLEAN ‚Üí FLOAT : Switch(False=0, True=1)")
    H.append("        if ('Boolean' in sid) and ('Float' in tid):")
    H.append("            try: sw = nt.nodes.new('FunctionNodeSwitch')")
    H.append("            except Exception: sw = nt.nodes.new('FunctionNodeSwitch')")
    H.append("            try: sw.input_type = 'FLOAT'")
    H.append("            except Exception: pass")
    H.append("            try:")
    H.append("                # defaults for False/True arms")
    H.append("                fv = sw.inputs.get('False'); tv = sw.inputs.get('True')")
    H.append("                if fv is not None: fv.default_value = 0.0")
    H.append("                if tv is not None: tv.default_value = 1.0")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(sa, sw.inputs.get('Switch'))")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(sw.outputs.get('Output') or sw.outputs.get('Result') or sw.outputs[0], sb); return True")
    H.append("            except Exception: return False")
    H.append("")

    H.append("        # INTEGER ‚Üí BOOLEAN : Compare(A != 0)")
    H.append("        if ('Int' in sid) and ('Boolean' in tid):")
    H.append("            try: cmpn = nt.nodes.new('FunctionNodeCompare')")
    H.append("            except Exception: cmpn = nt.nodes.new('FunctionNodeCompare')")
    H.append("            try: cmpn.data_type = 'INT'")
    H.append("            except Exception: pass")
    H.append("            try: cmpn.operation = 'NOT_EQUAL'")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(sa, cmpn.inputs.get('A', cmpn.inputs[0]))")
    H.append("            except Exception: pass")
    H.append("            try:")
    H.append("                b = cmpn.inputs.get('B')")
    H.append("                if b is not None: b.default_value = 0")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(cmpn.outputs.get('Result') or cmpn.outputs[0], sb); return True")
    H.append("            except Exception: return False")
    H.append("")

    H.append("        # BOOLEAN ‚Üí INTEGER : Switch(False=0, True=1)")
    H.append("        if ('Boolean' in sid) and ('Int' in tid):")
    H.append("            try: sw = nt.nodes.new('FunctionNodeSwitch')")
    H.append("            except Exception: sw = nt.nodes.new('FunctionNodeSwitch')")
    H.append("            try: sw.input_type = 'INT'")
    H.append("            except Exception: pass")
    H.append("            try:")
    H.append("                fv = sw.inputs.get('False'); tv = sw.inputs.get('True')")
    H.append("                if fv is not None: fv.default_value = 0")
    H.append("                if tv is not None: tv.default_value = 1")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(sa, sw.inputs.get('Switch'))")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(sw.outputs.get('Output') or sw.outputs.get('Result') or sw.outputs[0], sb); return True")
    H.append("            except Exception: return False")
    H.append("")

    H.append("        # VECTOR ‚Üî ROTATION (Euler): use Separate/Combine Euler when available")
    H.append("        if ('Vector' in sid) and ('Rotation' in tid):")
    H.append("            try: comb = nt.nodes.new('FunctionNodeCombineEuler')")
    H.append("            except Exception: comb = None")
    H.append("            if comb is not None:")
    H.append("                sep = _get_sep_xyz(nt, sa, getattr(sb, 'node', None))")
    H.append("                for vnm, enm in (('X','X'), ('Y','Y'), ('Z','Z')):")
    H.append("                    try: nt.links.new(sep.outputs.get(vnm), comb.inputs.get(enm))")
    H.append("                    except Exception: pass")
    H.append("                try: nt.links.new(comb.outputs.get('Rotation') or comb.outputs[0], sb); return True")
    H.append("                except Exception: return False")
    H.append("")
    H.append("        if ('Rotation' in sid) and ('Vector' in tid):")
    H.append("            try: sepE = nt.nodes.new('FunctionNodeSeparateEuler')")
    H.append("            except Exception: sepE = None")
    H.append("            if sepE is not None:")
    H.append("                try: nt.links.new(sa, sepE.inputs.get('Rotation') or sepE.inputs[0])")
    H.append("                except Exception: pass")
    H.append("                try: comb = nt.nodes.new('FunctionNodeCombineXYZ')")
    H.append("                except Exception: comb = nt.nodes.new('ShaderNodeCombineXYZ')")
    H.append("                for enm, vnm in (('X','X'), ('Y','Y'), ('Z','Z')):")
    H.append("                    try: nt.links.new(sepE.outputs.get(enm), comb.inputs.get(vnm))")
    H.append("                    except Exception: pass")
    H.append("                try: nt.links.new(comb.outputs.get('Vector', comb.outputs[0]), sb); return True")
    H.append("                except Exception: return False")
    
    H.append("        # === ADDITIONAL IMPLICIT‚ÜíEXPLICIT CASES (Geometry Nodes 4.x) ===")

    H.append("        # FLOAT ‚Üí VECTOR : replicate scalar across X,Y,Z via Combine XYZ")
    H.append("        if ('Float' in sid) and ('Vector' in tid):")
    H.append("            try: comb = nt.nodes.new('FunctionNodeCombineXYZ')")
    H.append("            except Exception: comb = nt.nodes.new('ShaderNodeCombineXYZ')")
    H.append("            try:")
    H.append("                sx, sy = getattr(sa.node, 'location', (0,0)); dx, dy = getattr(sb.node, 'location', (0,0))")
    H.append("                comb.location = ((sx+dx)*0.5 + 40, (sy+dy)*0.5)")
    H.append("            except Exception: pass")
    H.append("            for nm in ('X','Y','Z'):")
    H.append("                try: nt.links.new(sa, comb.inputs.get(nm))")
    H.append("                except Exception: pass")
    H.append("            try: nt.links.new(comb.outputs.get('Vector', comb.outputs[0]), sb); return True")
    H.append("            except Exception: return False")
    H.append("")

    H.append("        # COLOR ‚Üí VECTOR : map R,G,B to X,Y,Z")
    H.append("        if ('Color' in sid) and ('Vector' in tid):")
    H.append("            try: sepcol = nt.nodes.new('FunctionNodeSeparateColor')")
    H.append("            except Exception: sepcol = nt.nodes.new('ShaderNodeSeparateRGB')")
    H.append("            try: comb = nt.nodes.new('FunctionNodeCombineXYZ')")
    H.append("            except Exception: comb = nt.nodes.new('ShaderNodeCombineXYZ')")
    H.append("            try: nt.links.new(sa, sepcol.inputs.get('Color', sepcol.inputs[0]))")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(sepcol.outputs.get('Red') or sepcol.outputs.get('R'), comb.inputs.get('X'))")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(sepcol.outputs.get('Green') or sepcol.outputs.get('G'), comb.inputs.get('Y'))")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(sepcol.outputs.get('Blue') or sepcol.outputs.get('B'), comb.inputs.get('Z'))")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(comb.outputs.get('Vector', comb.outputs[0]), sb); return True")
    H.append("            except Exception: return False")
    H.append("")

    H.append("        # VECTOR ‚Üí COLOR : map X,Y,Z to R,G,B (A left at default 1)")
    H.append("        if ('Vector' in sid) and ('Color' in tid):")
    H.append("            sep = _get_sep_xyz(nt, sa, getattr(sb, 'node', None))")
    H.append("            try: comc = nt.nodes.new('FunctionNodeCombineColor')")
    H.append("            except Exception: comc = nt.nodes.new('ShaderNodeCombineRGB')")
    H.append("            try:")
    H.append("                sx, sy = getattr(sa.node, 'location', (0,0)); dx, dy = getattr(sb.node, 'location', (0,0))")
    H.append("                comc.location = ((sx+dx)*0.5 + 40, (sy+dy)*0.5)")
    H.append("            except Exception: pass")
    H.append("            for vnm, cnm in (('X','Red'), ('Y','Green'), ('Z','Blue')):")
    H.append("                try: nt.links.new(sep.outputs.get(vnm), comc.inputs.get(cnm))")
    H.append("                except Exception: pass")
    H.append("            try: nt.links.new(comc.outputs.get('Color') or comc.outputs.get('Image'), sb); return True")
    H.append("            except Exception: return False")
    H.append("")

    H.append("        # COLOR ‚Üí FLOAT : route single channel for targets named R/G/B (or Red/Green/Blue)")
    H.append("        if ('Color' in sid) and ('Float' in tid) and dn in {'R','G','B','Red','Green','Blue'}:")
    H.append("            try: sepcol = nt.nodes.new('FunctionNodeSeparateColor')")
    H.append("            except Exception: sepcol = nt.nodes.new('ShaderNodeSeparateRGB')")
    H.append("            try:")
    H.append("                sx, sy = getattr(sa.node, 'location', (0,0)); dx, dy = getattr(sb.node, 'location', (0,0))")
    H.append("                sepcol.location = ((sx+dx)*0.5 - 40, (sy+dy)*0.5)")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(sa, sepcol.inputs.get('Color', sepcol.inputs[0]))")
    H.append("            except Exception: pass")
    H.append("            ch = {'R':'Red','G':'Green','B':'Blue','Red':'Red','Green':'Green','Blue':'Blue'}[dn]")
    H.append("            out = sepcol.outputs.get(ch) or sepcol.outputs[{'Red':0,'Green':1,'Blue':2}[ch]]")
    H.append("            try: nt.links.new(out, sb); return True")
    H.append("            except Exception: return False")
    H.append("")

    H.append("        # FLOAT ‚Üí COLOR : gray from scalar, Alpha = 1")
    H.append("        if ('Float' in sid) and ('Color' in tid):")
    H.append("            try: comc = nt.nodes.new('FunctionNodeCombineColor')")
    H.append("            except Exception: comc = nt.nodes.new('ShaderNodeCombineRGB')")
    H.append("            try:")
    H.append("                sx, sy = getattr(sa.node, 'location', (0,0)); dx, dy = getattr(sb.node, 'location', (0,0))")
    H.append("                comc.location = ((sx+dx)*0.5 + 40, (sy+dy)*0.5)")
    H.append("            except Exception: pass")
    H.append("            for nm in ('Red','Green','Blue'):")
    H.append("                try: nt.links.new(sa, comc.inputs.get(nm))")
    H.append("                except Exception: pass")
    H.append("            try:")
    H.append("                a = comc.inputs.get('Alpha')")
    H.append("                if a is not None: a.default_value = 1.0")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(comc.outputs.get('Color') or comc.outputs.get('Image'), sb); return True")
    H.append("            except Exception: return False")
    H.append("")

    H.append("        # FLOAT ‚Üí INT/INDEX : explicit Float‚ÜíInteger")
    H.append("        if ('Float' in sid) and ('Int' in tid or dn in {'Index','INT','Int'}):")
    H.append("            try: f2i = nt.nodes.new('FunctionNodeFloatToInt')")
    H.append("            except Exception: f2i = nt.nodes.new('FunctionNodeFloatToInt')")
    H.append("            try:")
    H.append("                sx, sy = getattr(sa.node, 'location', (0,0)); dx, dy = getattr(sb.node, 'location', (0,0))")
    H.append("                f2i.location = ((sx+dx)*0.5, (sy+dy)*0.5)")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(sa, f2i.inputs.get('Float', f2i.inputs[0]))")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(f2i.outputs.get('Integer', f2i.outputs[0]), sb); return True")
    H.append("            except Exception: return False")
    H.append("")

    H.append("        # INT ‚Üí FLOAT : force cast via Math (Add 0.0)")
    H.append("        if ('Int' in sid) and ('Float' in tid):")
    H.append("            try: m = nt.nodes.new('ShaderNodeMath')")
    H.append("            except Exception: m = nt.nodes.new('ShaderNodeMath')")
    H.append("            try: m.operation = 'ADD'")
    H.append("            except Exception: pass")
    H.append("            try: m.inputs[1].default_value = 0.0")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(sa, m.inputs.get('Value', m.inputs[0]))")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(m.outputs.get('Value', m.outputs[0]), sb); return True")
    H.append("            except Exception: return False")
    H.append("")

    H.append("        # FLOAT ‚Üí BOOLEAN : Compare(A > 0)")
    H.append("        if ('Float' in sid) and ('Boolean' in tid):")
    H.append("            try: cmpn = nt.nodes.new('FunctionNodeCompare')")
    H.append("            except Exception: cmpn = nt.nodes.new('FunctionNodeCompare')")
    H.append("            try: cmpn.data_type = 'FLOAT'")
    H.append("            except Exception: pass")
    H.append("            try: cmpn.operation = 'GREATER_THAN'")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(sa, cmpn.inputs.get('A', cmpn.inputs[0]))")
    H.append("            except Exception: pass")
    H.append("            try:")
    H.append("                b = cmpn.inputs.get('B')")
    H.append("                if b is not None: b.default_value = 0.0")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(cmpn.outputs.get('Result') or cmpn.outputs[0], sb); return True")
    H.append("            except Exception: return False")
    H.append("")

    H.append("        # BOOLEAN ‚Üí FLOAT : Switch(False=0, True=1)")
    H.append("        if ('Boolean' in sid) and ('Float' in tid):")
    H.append("            try: sw = nt.nodes.new('FunctionNodeSwitch')")
    H.append("            except Exception: sw = nt.nodes.new('FunctionNodeSwitch')")
    H.append("            try: sw.input_type = 'FLOAT'")
    H.append("            except Exception: pass")
    H.append("            try:")
    H.append("                fv = sw.inputs.get('False'); tv = sw.inputs.get('True')")
    H.append("                if fv is not None: fv.default_value = 0.0")
    H.append("                if tv is not None: tv.default_value = 1.0")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(sa, sw.inputs.get('Switch'))")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(sw.outputs.get('Output') or sw.outputs.get('Result') or sw.outputs[0], sb); return True")
    H.append("            except Exception: return False")
    H.append("")

    H.append("        # INT ‚Üí BOOLEAN : Compare(A != 0)")
    H.append("        if ('Int' in sid) and ('Boolean' in tid):")
    H.append("            try: cmpn = nt.nodes.new('FunctionNodeCompare')")
    H.append("            except Exception: cmpn = nt.nodes.new('FunctionNodeCompare')")
    H.append("            try: cmpn.data_type = 'INT'")
    H.append("            except Exception: pass")
    H.append("            try: cmpn.operation = 'NOT_EQUAL'")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(sa, cmpn.inputs.get('A', cmpn.inputs[0]))")
    H.append("            except Exception: pass")
    H.append("            try:")
    H.append("                b = cmpn.inputs.get('B')")
    H.append("                if b is not None: b.default_value = 0")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(cmpn.outputs.get('Result') or cmpn.outputs[0], sb); return True")
    H.append("            except Exception: return False")
    H.append("")

    H.append("        # BOOLEAN ‚Üí INT : Switch(False=0, True=1)")
    H.append("        if ('Boolean' in sid) and ('Int' in tid):")
    H.append("            try: sw = nt.nodes.new('FunctionNodeSwitch')")
    H.append("            except Exception: sw = nt.nodes.new('FunctionNodeSwitch')")
    H.append("            try: sw.input_type = 'INT'")
    H.append("            except Exception: pass")
    H.append("            try:")
    H.append("                fv = sw.inputs.get('False'); tv = sw.inputs.get('True')")
    H.append("                if fv is not None: fv.default_value = 0")
    H.append("                if tv is not None: tv.default_value = 1")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(sa, sw.inputs.get('Switch'))")
    H.append("            except Exception: pass")
    H.append("            try: nt.links.new(sw.outputs.get('Output') or sw.outputs.get('Result') or sw.outputs[0], sb); return True")
    H.append("            except Exception: return False")
    H.append("")

    H.append("        # VECTOR ‚Üî ROTATION (Euler): use Separate/Combine Euler when present")
    H.append("        if ('Vector' in sid) and ('Rotation' in tid):")
    H.append("            try: combE = nt.nodes.new('FunctionNodeCombineEuler')")
    H.append("            except Exception: combE = None")
    H.append("            if combE is not None:")
    H.append("                sep = _get_sep_xyz(nt, sa, getattr(sb, 'node', None))")
    H.append("                for vnm, enm in (('X','X'), ('Y','Y'), ('Z','Z')):")
    H.append("                    try: nt.links.new(sep.outputs.get(vnm), combE.inputs.get(enm))")
    H.append("                    except Exception: pass")
    H.append("                try: nt.links.new(combE.outputs.get('Rotation') or combE.outputs[0], sb); return True")
    H.append("                except Exception: return False")
    H.append("")
    H.append("        if ('Rotation' in sid) and ('Vector' in tid):")
    H.append("            try: sepE = nt.nodes.new('FunctionNodeSeparateEuler')")
    H.append("            except Exception: sepE = None")
    H.append("            if sepE is not None:")
    H.append("                try: nt.links.new(sa, sepE.inputs.get('Rotation') or sepE.inputs[0])")
    H.append("                except Exception: pass")
    H.append("                try: comb = nt.nodes.new('FunctionNodeCombineXYZ')")
    H.append("                except Exception: comb = nt.nodes.new('ShaderNodeCombineXYZ')")
    H.append("                for enm, vnm in (('X','X'), ('Y','Y'), ('Z','Z')):")
    H.append("                    try: nt.links.new(sepE.outputs.get(enm), comb.inputs.get(vnm))")
    H.append("                    except Exception: pass")
    H.append("                try: nt.links.new(comb.outputs.get('Vector', comb.outputs[0]), sb); return True")
    H.append("                except Exception: return False")

    H.append("")
    H.append("        # Otherwise, try a plain link and log what we saw (to help extend cases).")
    H.append("        try:")
    H.append("            nt.links.new(fs, ts)")
    H.append("            return True")
    H.append("        except Exception as ex2:")
    H.append("            _warn(f\"Implicit convert not handled ({ft} ‚Üí {tt}) for {getattr(fs.node,'name','?')}.{getattr(fs,'name','')} ‚Üí {getattr(ts.node,'name','?')}.{getattr(ts,'name','')}: {ex2}\")")
    H.append("            return False")
    H.append("    except Exception as ex:")
    H.append("        _warn(f\"Failed to link {getattr(fs.node,'name',type(fs.node).__name__)}.{getattr(fs,'name','')} -> {getattr(ts.node,'name',type(ts.node).__name__)}.{getattr(ts,'name','')}: {ex}\")")
    H.append("        return False")


    H.append("def _ensure_group(name, tree_type='GEOMETRY'):")
    H.append("    tree_type_map = {")
    H.append("        'GEOMETRY': 'GeometryNodeTree',")
    H.append("        'MATERIAL': 'ShaderNodeTree',")
    H.append("        'COMPOSITOR': 'CompositorNodeTree'")
    H.append("    }")
    H.append("    nt_type = tree_type_map.get(tree_type, 'GeometryNodeTree')")
    H.append("    return bpy.data.node_groups.new(f'BNDL_Replay::{name}', nt_type)")

    H.append("def _apply_dynamic_for_node(n, steps):")
    H.append("    # Index Switch case count & renames")
    H.append("    try: bid = n.bl_idname")
    H.append("    except Exception: bid = ''")
    H.append("    # case count")
    H.append("    for st in steps:")
    H.append("        if st.get('kind')=='adjust_cases' and st['node']['ui_type']==getattr(n,'name',''):")
    H.append("            pass  # name-based fallback (usually not used)")
    H.append("    # property-based matching by UI label+inst via idmap is done by callers")
    H.append("")

    H.append("def _set_index_switch_cases(n, count):")
    H.append("    # 1) integer-style attributes")
    H.append("    for attr in ('input_count','inputs_count','case_count','items_count'):")
    H.append("        try:")
    H.append("            setattr(n, attr, int(count))")
    H.append("            return True")
    H.append("        except Exception:")
    H.append("            pass")
    H.append("    # 2) collection-style attributes (grow with add/new)")
    H.append("    for coll_name in ('index_switch_items','switch_items','items'):")
    H.append("        try:")
    H.append("            coll = getattr(n, coll_name)")
    H.append("        except Exception:")
    H.append("            coll = None")
    H.append("        if coll is None: continue")
    H.append("        try:")
    H.append("            # some collections have .add(), some have .new()")
    H.append("            add_fn = getattr(coll, 'add', None) or getattr(coll, 'new', None)")
    H.append("            if add_fn is None: continue")
    H.append("            # grow to requested count")
    H.append("            while len(coll) < int(count):")
    H.append("                add_fn()")
    H.append("            # shrink if oversized")
    H.append("            while len(coll) > int(count):")
    H.append("                try: coll.remove(coll[-1])")
    H.append("                except Exception: break")
    H.append("            return True")
    H.append("        except Exception:")
    H.append("            pass")
    H.append("    return False")
    H.append("")

    H.append("def _infer_index_switch_counts(steps):")
    H.append("    \"\"\"Infer required case count for Index Switch from declare *and* connect targets.\"\"\"")
    H.append("    need = {}  # key: (ui, inst) -> count")
    H.append("    import re")
    H.append("    # 1) From declare blocks")
    H.append("    for st in steps:")
    H.append("        if st.get('kind')=='declare' and st['node']['ui_type']=='Index Switch' and st.get('side')=='inputs':")
    H.append("            mx = -1")
    H.append("            for label in st.get('ports', []):")
    H.append("                m = re.match(r'^(\\d+)$', str(label).strip())")
    H.append("                if m: mx = max(mx, int(m.group(1)))")
    H.append("            if mx >= 0:")
    H.append("                key = (st['node']['ui_type'], st['node']['inst'] or '')")
    H.append("                need[key] = max(need.get(key, 0), mx+1)")
    H.append("    # 2) From connect targets like '2' or 'Case 3'")
    H.append("    for st in steps:")
    H.append("        if st.get('kind') != 'connect':")
    H.append("            continue")
    H.append("        to = st.get('to', {})")
    H.append("        if to.get('ui_type') != 'Index Switch':")
    H.append("            continue")
    H.append("        lab = str(st.get('to_port','')).strip()")
    H.append("        m_num  = re.match(r'^(\\d+)$', lab)")
    H.append("        m_case = re.match(r'^Case\\s+(\\d+)$', lab, flags=re.I)")
    H.append("        mx = int(m_num.group(1)) if m_num else (int(m_case.group(1)) if m_case else None)")
    H.append("        if mx is not None:")
    H.append("            key = (to['ui_type'], to.get('inst') or '')")
    H.append("            need[key] = max(need.get(key, 0), mx+1)")
    H.append("    return need")


    H.append("def _layout_minimal(ntree, x_gap=260, y_gap=140):")
    H.append("    \"\"\"Very small, dependency-aware layout.")
    H.append("    - Columns (x): 1 + max(parent column) from any source node.")
    H.append("    - Rows (y): simple index within each column.")
    H.append("    Avoids stacked overlaps; zero external deps.\"\"\"")
    H.append("    nodes = list(ntree.nodes)")
    H.append("    incoming = {n: [] for n in nodes}")
    H.append("    for L in ntree.links:")
    H.append("        incoming[L.to_node].append(L.from_node)")
    H.append("    # Longest-path rank (column index)")
    H.append("    rank = {n: (0 if not incoming[n] else 1) for n in nodes}")
    H.append("    for _ in range(len(nodes) + 5):")
    H.append("        changed = False")
    H.append("        for n in nodes:")
    H.append("            parents = incoming[n]")
    H.append("            new_r = 0 if not parents else 1 + max(rank[p] for p in parents)")
    H.append("            if new_r != rank[n]:")
    H.append("                rank[n] = new_r; changed = True")
    H.append("        if not changed: break")
    H.append("    # Bucket by column and place")
    H.append("    cols = {}")
    H.append("    for n, r in rank.items():")
    H.append("        cols.setdefault(r, []).append(n)")
    H.append("    for r in cols:")
    H.append("        cols[r].sort(key=lambda x: (getattr(x,'bl_idname',''), getattr(x,'name','')))")
    H.append("    for r, col in cols.items():")
    H.append("        for i, n in enumerate(col):")
    H.append("            n.location.x = r * x_gap")
    H.append("            n.location.y = -i * y_gap")
    H.append("")

    H.append("def _set_enum_by_ui_label(node, prop_name, label):")
    H.append("    try:")
    H.append("        prop = node.bl_rna.properties.get(prop_name)")
    H.append("        if prop and prop.type == 'ENUM':")
    H.append("            for item in prop.enum_items:")
    H.append("                if item.name == label or item.identifier == label:")
    H.append("                    setattr(node, prop_name, item.identifier)")
    H.append("                    return True")
    H.append("    except Exception:")
    H.append("        pass")
    H.append("    return False")
    H.append("")

    H.append("def _new_link_with_convert(nt, sock_from, sock_to):")
    H.append("    try:")
    H.append("        nt.links.new(sock_from, sock_to)")
    H.append("        return True")
    H.append("    except Exception as e:")
    H.append("        print(f'[BNDL] Link error: {e}')")
    H.append("        return False")
    H.append("")

    H.append("def _populate_group(name, steps, built_groups):")
    H.append("    ng = built_groups[name]")
    H.append("    nt = ng; nodes = nt.nodes; links = nt.links")
    H.append("    nodes.clear()")

    H.append("    gi_ports = []; go_ports = []")
    H.append("    for st in steps:")
    H.append("        if st.get('kind') != 'declare':")
    H.append("            continue")
    H.append("        ui = st['node']['ui_type']; side = st['side']")
    H.append("        if ui == 'Group Input' and side.lower() == 'outputs':")
    H.append("            for p in st['ports']: gi_ports.append((p, _guess_socket_type(p)))")
    H.append("        if ui == 'Group Output' and side.lower() == 'inputs':")
    H.append("            for p in st['ports']: go_ports.append((p, _guess_socket_type(p)))")

    H.append("    # collect Expose lines too (v1.3)")
    H.append("    exp_gi = []; exp_go = []")
    H.append("    for st in steps:")
    H.append("        if st.get('kind') == 'expose':")
    H.append("            ui = st['node']['ui_type']")
    H.append("            p  = st.get('port','')")
    H.append("            if ui == 'Group Input' and p:")
    H.append("                exp_gi.append((p, _guess_socket_type(p)))")
    H.append("            if ui == 'Group Output' and p:")
    H.append("                exp_go.append((p, _guess_socket_type(p)))")
    H.append("    inf_gi, inf_go = _infer_interface_ports(steps)")

    H.append("    have = set(n for n,_ in gi_ports)")
    H.append("    for n,t in inf_gi + exp_gi:")
    H.append("        if n not in have:")
    H.append("            gi_ports.append((n,t)); have.add(n)")
    H.append("    have = set(n for n,_ in go_ports)")
    H.append("    for n,t in inf_go + exp_go:")
    H.append("        if n not in have:")
    H.append("            go_ports.append((n,t)); have.add(n)")
    H.append("        if n not in have: go_ports.append((n,t)); have.add(n)")
    H.append("    # Defer interface build; we‚Äôll do it after creates + type-affecting pre-apply")
    H.append("    _declared_iface = (list(gi_ports), list(go_ports))")

    H.append("    idmap = {}")
    H.append("    for st in steps:")
    H.append("        if st['kind'] != 'create': continue")
    H.append("        ui = st['node']['ui_type']; inst = st['node']['inst'] or ''")
    H.append("        blid = st['node']['bl_idname'] or ('NodeGroupInput' if ui=='Group Input' else 'NodeGroupOutput' if ui=='Group Output' else ui)")
    H.append("        try: n = nodes.new(blid)")
    H.append("        except Exception:")
    H.append("            try: n = nodes.new('NodeReroute'); _warn(f'Unknown node type {blid}, using Reroute.')")
    H.append("            except Exception: continue")

    H.append("        if ui == 'Group':")
    H.append("            gname = st['node'].get('label')")
    H.append("            cand = [gname] if gname else []")
    H.append("            if gname:")
    H.append("                cand.append(gname.replace(' ', '_'))")
    H.append("                cand.append(gname.replace('_', ' '))")
    H.append("            attached = False")
    H.append("            for key in cand:")
    H.append("                if key and key in built_groups:")
    H.append("                    try:")
    H.append("                        n.node_tree = built_groups[key]")
    H.append("                        attached = True")
    H.append("                        break")
    H.append("                    except Exception:")
    H.append("                        _warn(f\"Group {name}: failed to assign node_tree for inner Group: {key}\")")
    H.append("            if not attached:")
    H.append("                _warn(f\"Group {name}: no node_tree attached for inner Group label='{gname}'. Known groups: {list(built_groups.keys())[:6]}\")")

    H.append("        idmap[(ui, inst)] = n")
    H.append("    if ('Group Input','1') not in idmap: idmap[('Group Input','1')] = nodes.new('NodeGroupInput')")
    H.append("    if ('Group Output','1') not in idmap: idmap[('Group Output','1')] = nodes.new('NodeGroupOutput')")

    H.append("    # pre-apply settings that CHANGE SOCKET TYPES (must run before interface inference)")
    H.append("    TYPE_AFFECT = {'Index Switch', 'Random Value', 'Switch', 'Compare', 'Map Range'}")
    H.append("    for st in steps:")
    H.append("        if st.get('kind') != 'set':")
    H.append("            continue")
    H.append("        ui = st['node']['ui_type']")
    H.append("        if ui not in TYPE_AFFECT:")
    H.append("            continue")
    H.append("        n = idmap.get((ui, st['node']['inst'] or ''))")
    H.append("        if not n:")
    H.append("            continue")
    H.append("        for kv in st['entries']:")
    H.append("            k = str(kv['key']).strip()")
    H.append("            # These UI keys directly affect socket idnames")
    H.append("            if k in {'Data Type', 'Input Type'}:")
    H.append("                _apply_kv(n, kv['key'], kv['val'])")
    H.append("")
    H.append("    # Build interface now that the affected nodes expose the correct socket types")
    H.append("    # Defer interface build; we‚Äôll do it after creates + type-affecting pre-apply")
    H.append("    gi_ports = []; go_ports = []")

    H.append("    _gi_decl, _go_decl = _declared_iface")
    H.append("    _gi_graph, _go_graph = _infer_interface_ports_from_graph(nt, idmap, steps)")
    H.append("    # Order must follow DECLARE; use graph only to refine types, and add extras at the end.")
    H.append("    _gimap = {n:t for (n,t) in _gi_graph}")
    H.append("    _gomap = {n:t for (n,t) in _go_graph}")
    H.append("    _merged_gi = []")
    H.append("    _seen = set()")
    H.append("    for (n,t) in _gi_decl:")
    H.append("        _merged_gi.append((n, _gimap.get(n, t))); _seen.add(n)")
    H.append("    for (n,t) in _gi_graph:")
    H.append("        if n not in _seen: _merged_gi.append((n,t))")
    H.append("    _merged_go = []")
    H.append("    _seen = set()")
    H.append("    for (n,t) in _go_decl:")
    H.append("        _merged_go.append((n, _gomap.get(n, t))); _seen.add(n)")
    H.append("    for (n,t) in _go_graph:")
    H.append("        if n not in _seen: _merged_go.append((n,t))")
    H.append("")

    H.append("    rebuild_interface(ng, _merged_gi, _merged_go)")
    H.append("    _apply_pending_gi_defaults(ng)")
    H.append("    # dynamic adjustments (e.g., Index Switch cases) before any other sets/links")
    H.append("    for st in steps:")
    H.append("        if st.get('kind') == 'adjust_cases':")
    H.append("            n = idmap.get((st['node']['ui_type'], st['node']['inst'] or ''))")
    H.append("            if n: _set_index_switch_cases(n, st['count'])")
    H.append("    # inferred case counts from Declare lines (if exporter didn‚Äôt emit adjust_cases)")


    H.append("    req = _infer_index_switch_counts(steps)")
    H.append("    for key, cnt in req.items():")
    H.append("        n = idmap.get(key);  _set_index_switch_cases(n, cnt) if n else None")
    H.append("    # pair zones (Simulation/Repeat) inside groups before any sets/links")
    H.append("    for st in steps:")
    H.append("        if st.get('kind') != 'pairzone': continue")
    H.append("        L = idmap.get((st['left']['ui_type'],  st['left']['inst']  or ''))")
    H.append("        R = idmap.get((st['right']['ui_type'], st['right']['inst'] or ''))")
    H.append("        if not L or not R: continue")
    H.append("        paired = False")
    H.append("        # Prefer the official API: input.pair_with_output(output)")
    H.append("        f = getattr(L, 'pair_with_output', None)")
    H.append("        if callable(f):")
    H.append("            try: f(R); paired = True")
    H.append("            except Exception: pass")
    H.append("        if not paired:")
    H.append("            # Try symmetric/fallback names just in case")
    H.append("            g = getattr(R, 'pair_with_input', None)")
    H.append("            if callable(g):")
    H.append("                try: g(L); paired = True")
    H.append("                except Exception: pass")
    H.append("        if not paired:")
    H.append("            _warn(f\"Group {name}: failed to pair zone {getattr(L,'name','?')} <-> {getattr(R,'name','?')}\")")

    H.append("    # set props (after structure adjusted)")
    H.append("    # --- Collect SetUser overrides for this GROUP's Group Input ---")
    H.append("    gi_user = {}")
    H.append("    for st in steps:")
    H.append("        if st.get('kind') == 'set_user' and st['node']['ui_type'] == 'Group Input':")
    H.append("            for kv in st['entries']:")
    H.append("                k = _normalize_gi_key(kv['key'])")
    H.append("                gi_user[k] = kv['val']")

    H.append("    for st in steps:")
    H.append("        if st['kind'] != 'set':")
    H.append("            continue")
    H.append("")
    H.append("        ui = st['node']['ui_type']")
    H.append("        inst = st['node']['inst'] or ''")
    H.append("        n = idmap.get((ui, inst))")
    H.append("        if not n:")
    H.append("            continue")
    H.append("")
    H.append("        # --- Group Input interface defaults (GROUP) with SetUser overrides ---")
    H.append("        if ui == 'Group Input':")
    H.append("            try:")
    H.append("                seen = set()")
    H.append("                for kv in st['entries']:")
    H.append("                    k = _normalize_gi_key(kv['key'])")
    H.append("                    if k in seen: continue")
    H.append("                    seen.add(k)")
    H.append("                    _queue_gi_default(ng, k, kv['val'])")
    H.append("                for k, raw in gi_user.items():")
    H.append("                    _queue_gi_override(ng, k, raw)")
    H.append("                _apply_pending_gi_defaults(ng)")
    H.append("            except Exception as ex:")
    H.append("                _warn(f'Group {name}: failed GI defaults apply: {ex}')")
    H.append("            continue  # done handling Group Input defaults")
    H.append("")
    H.append("        # CRITICAL: For Mix nodes with 'data_type', process it FIRST so sockets regenerate before other entries")
    H.append("        entries = st['entries']")
    H.append("        if hasattr(n, 'data_type'):")
    H.append("            # Find data_type entry and move it to front")
    H.append("            dtype_entry = None")
    H.append("            other_entries = []")
    H.append("            for kv in entries:")
    H.append("                if str(kv['key']).strip().lower() == 'data_type':")
    H.append("                    dtype_entry = kv")
    H.append("                else:")
    H.append("                    other_entries.append(kv)")
    H.append("            if dtype_entry:")
    H.append("                entries = [dtype_entry] + other_entries")
    H.append("")
    H.append("        for kv in entries:")
    H.append("            _apply_kv(n, kv['key'], kv['val'])")
    H.append("")

    H.append("    # renames (after sockets exist)")
    H.append("    for st in steps:")
    H.append("        if st.get('kind') == 'rename_input':")
    H.append("            n = idmap.get((st['node']['ui_type'], st['node']['inst'] or ''))")
    H.append("            if not n: continue")
    H.append("            # try exact match; else Case N ‚Üí index")
    H.append("            sock = n.inputs.get(st['old'])")
    H.append("            if sock is None:")
    H.append("                import re")
    H.append("                m = re.match(r'^Case\\s+(\\d+)$', st['old'], flags=re.I)")
    H.append("                if m:")
    H.append("                    idx = int(m.group(1)) - 1")
    H.append("                    if 0 <= idx < len(n.inputs): sock = n.inputs[idx]")
    H.append("            if sock is not None: sock.name = st['new']")

    H.append("    # node label renames")
    H.append("    for st in steps:")

    H.append("        if st.get('kind') == 'rename_node':")
    H.append("            n = idmap.get((st['node']['ui_type'], st['node']['inst'] or ''))")
    H.append("            if not n: ")
    H.append("                continue")
    H.append("            try:")
    H.append("                n.label = st['label']")
    H.append("            except Exception:")
    H.append("                pass")

    H.append("    for st in steps:")
    H.append("        if st['kind'] != 'connect': continue")
    H.append("        dst = idmap.get((st['to']['ui_type'], st['to']['inst'] or ''))")
    H.append("        if not dst: _warn(f\"Target missing (group {name}): {st['to']}\"); continue")
    H.append("        if st.get('from_field'):_warn(f\"Skipping dotted field literal in group {name}: '{st['from_field']}'\"); continue")
    H.append("        src = idmap.get((st['from']['ui_type'], st['from']['inst'] or '')) if st.get('from') else None")
    H.append("        if not src: _warn(f\"Source missing (group {name}): {st.get('from')}\"); continue")
    H.append("        sa = resolve_socket_by_display(src, 'out', st['from_port'])")
    H.append("        sb = resolve_socket_by_display(dst, 'in',  st['to_port'])")
    H.append("        # CRITICAL FIX: Mix node socket type refinement for connections")
    H.append("        print(f\"[CONNECT-MIX-FIX-v1] Before refinement: dst={getattr(dst,'name','?')}, port={st['to_port']}, sb={sb}\")")
    H.append("        if sb is not None and hasattr(dst, 'data_type'):")
    H.append("            try:")
    H.append("                dtype = getattr(dst, 'data_type', None)")
    H.append("                port_name = str(st['to_port']).strip()")
    H.append("                if dtype and port_name in ('A', 'B', 'Factor', 'Result'):")
    H.append("                    sock_list = [s for s in getattr(dst, 'inputs', []) if getattr(s, 'name', '') == port_name]")
    H.append("                    if len(sock_list) > 1:")
    H.append("                        type_map = {'RGBA': 'Color', 'FLOAT': 'Float', 'VECTOR': 'Vector', 'ROTATION': 'Rotation'}")
    H.append("                        wanted = type_map.get(dtype, 'Float')")
    H.append("                        for s in sock_list:")
    H.append("                            if wanted in (getattr(s, 'bl_idname', '') or type(s).__name__):")
    H.append("                                sb = s")
    H.append("                                print(f\"[CONNECT-MIX-FIX-v1] Refined to {wanted}: {sb}\")")
    H.append("                                break")
    H.append("            except Exception as ex:")
    H.append("                print(f\"[CONNECT-MIX-FIX-v1] Refinement failed: {ex}\")")
    H.append("        if sa is None or sb is None:")
    H.append("            _warn(f\"Group {name}: skip link {src.name}.{st['from_port']} -> {dst.name}.{st['to_port']} (unresolved socket)\")")
    H.append("        else:")
    H.append("            if not _new_link_with_convert(nt, sa, sb):")
    H.append("                _warn(f\"Skip link {src.name}.{st['from_port']} -> {dst.name}.{st['to_port']} (link failed)\")")
    H.append("")

    H.append("    _layout_minimal(nt)")
    H.append("def _build_groups(groups_ir, tree_type='GEOMETRY'):")
    H.append("    # Phase 1: ensure all groups exist (so inner Group nodes can reference them by name)")
    H.append("    built = {}")
    H.append("    for g in groups_ir:")
    H.append("        name = g.get('name') or 'NodeGroup'")
    H.append("        built[name] = _ensure_group(name, tree_type)")
    H.append("    # Phase 2: populate in reverse order so nested groups get their interface first")
    H.append("    for g in reversed(list(groups_ir)):")
    H.append("        name = g.get('name') or 'NodeGroup'")
    H.append("        _populate_group(name, g.get('steps', []), built)")
    H.append("    return built")
    H.append("")

    # ---------- Top-level build (uses built groups) ----------
    H.append("def build_top_on_active_object(top_ir, groups_ir, tree_type='GEOMETRY', tree_name='BNDL_Tree'):")
    H.append("    ctx = bpy.context; ob = ctx.active_object")
    H.append("    if not ob: _warn('No active object selected.'); return None")
    H.append("    built_groups = _build_groups(groups_ir, tree_type)")
    
    # Determine node tree type and modifier type based on tree_type
    H.append("    if tree_type == 'GEOMETRY':")
    H.append("        ng = bpy.data.node_groups.new(tree_name, 'GeometryNodeTree')")
    H.append("        mod = ob.modifiers.new(name='GeometryNodes', type='NODES')")
    H.append("        mod.node_group = ng")
    H.append("    elif tree_type == 'MATERIAL':")
    H.append("        # Create new material")
    H.append("        mat = bpy.data.materials.new(name=tree_name)")
    H.append("        mat.use_nodes = True")
    H.append("        ng = mat.node_tree")
    H.append("        # Assign to object")
    H.append("        if ob.data and hasattr(ob.data, 'materials'):")
    H.append("            if not ob.data.materials:")
    H.append("                ob.data.materials.append(mat)")
    H.append("            else:")
    H.append("                ob.data.materials[0] = mat")
    H.append("        else:")
    H.append("            _warn('Active object does not support materials')")
    H.append("            return None")
    H.append("    elif tree_type == 'COMPOSITOR':")
    H.append("        ng = bpy.data.node_groups.new(tree_name, 'CompositorNodeTree')")
    H.append("        # For compositor, add to scene compositor")
    H.append("        scene = ctx.scene")
    H.append("        if not scene.use_nodes:")
    H.append("            scene.use_nodes = True")
    H.append("        # Add group node to compositor")
    H.append("        group_node = scene.node_tree.nodes.new(type='CompositorNodeGroup')")
    H.append("        group_node.node_tree = ng")
    H.append("        group_node.location = (0, 0)")
    H.append("        # Connect to composite output if possible")
    H.append("        comp_output = None")
    H.append("        for node in scene.node_tree.nodes:")
    H.append("            if node.type == 'COMPOSITE':")
    H.append("                comp_output = node")
    H.append("                break")
    H.append("        if comp_output and group_node.outputs:")
    H.append("            for output in group_node.outputs:")
    H.append("                if 'Color' in output.type or 'RGBA' in output.type:")
    H.append("                    scene.node_tree.links.new(output, comp_output.inputs['Image'])")
    H.append("                    break")
    H.append("    else:")
    H.append("        _warn(f'Unsupported tree type: {tree_type}')")
    H.append("        return None")
    
    H.append("    nt = ng; nodes = nt.nodes; links = nt.links")
    H.append("    nodes.clear()")
    H.append("    idmap = {}")

    H.append("    # interface first (declare + inferred from connects)")
    H.append("    # Defer interface build until nodes exist; see below.")
    H.append("    gi_ports = []; go_ports = []")

    H.append("    # create")
    H.append("    for st in top_ir['steps']:")
    H.append("        if st['kind'] != 'create': continue")
    H.append("        ui = st['node']['ui_type']; inst = st['node']['inst'] or ''")
    H.append("        blid = st['node']['bl_idname'] or ('NodeGroupInput' if ui=='Group Input' else 'NodeGroupOutput' if ui=='Group Output' else ui)")
    H.append("        try: n = nodes.new(blid)")
    H.append("        except Exception:")
    H.append("            try: n = nodes.new('NodeReroute'); _warn(f'Unknown node type {blid}, using Reroute.')")
    H.append("            except Exception: continue")

    H.append("        # If this is a Group node, attach the built group by name")
    H.append("        if ui == 'Group':")
    H.append("            raw = st['node'].get('label')")
    H.append("            gname = raw or (next(iter(built_groups.keys())) if built_groups else None)")
    H.append("            cand = [gname] if gname else []")
    H.append("            if gname:")
    H.append("                cand.append(gname.replace(' ', '_'))")
    H.append("                cand.append(gname.replace('_', ' '))")
    H.append("            attached = False")
    H.append("            for key in cand:")
    H.append("                if key and key in built_groups:")
    H.append("                    try:")
    H.append("                        n.node_tree = built_groups[key]")
    H.append("                        attached = True")
    H.append("                        break")
    H.append("                    except Exception:")
    H.append("                        _warn(f\"Failed to assign node_tree for Group: {key}\")")
    H.append("            if not attached:")
    H.append("                _warn(f\"No node_tree attached for Group label='{raw}'. Known groups: {list(built_groups.keys())[:6]}\")")

    H.append("        idmap[(ui, inst)] = n")
    H.append("    # ensure GI/GO nodes exist (ONLY for Node Groups, not Materials)")
    H.append("    if tree_type != 'MATERIAL':")
    H.append("        if ('Group Input','1') not in idmap: idmap[('Group Input','1')] = nodes.new('NodeGroupInput')")
    H.append("        if ('Group Output','1') not in idmap: idmap[('Group Output','1')] = nodes.new('NodeGroupOutput')")

    H.append("    # pre-apply settings that CHANGE SOCKET TYPES (top level)")
    H.append("    TYPE_AFFECT = {'Index Switch', 'Random Value', 'Switch', 'Compare', 'Map Range'}")
    H.append("    for st in top_ir['steps']:")
    H.append("        if st.get('kind') != 'set':")
    H.append("            continue")
    H.append("        ui = st['node']['ui_type']")
    H.append("        if ui not in TYPE_AFFECT:")
    H.append("            continue")
    H.append("        n = idmap.get((ui, st['node']['inst'] or ''))")
    H.append("        if not n:")
    H.append("            continue")
    H.append("        for kv in st['entries']:")
    H.append("            k = str(kv['key']).strip()")
    H.append("            if k in {'Data Type', 'Input Type'}:")
    H.append("                _apply_kv(n, kv['key'], kv['val'])")
    H.append("")
    H.append("    # Build interface now that the affected nodes expose the correct socket types")
    H.append("    gi_ports = []; go_ports = []")
    H.append("    for st in top_ir['steps']:")
    H.append("        if st.get('kind') != 'declare':")
    H.append("            continue")
    H.append("        ui = st['node']['ui_type']; side = st['side']")
    H.append("        print(f\"[DEBUG] Declare: ui={ui}, side={side}, ports={st['ports']}\")")
    H.append("        if ui == 'Group Input' and side.lower() == 'outputs':")
    H.append("            for p in st['ports']: gi_ports.append((p, _guess_socket_type(p)))")
    H.append("        if ui == 'Group Output' and side.lower() == 'inputs':")
    H.append("            for p in st['ports']: go_ports.append((p, _guess_socket_type(p)))")

    H.append("    # collect Expose lines too (v1.3)")
    H.append("    exp_gi = []; exp_go = []")
    H.append("    for st in top_ir['steps']:")
    H.append("        if st.get('kind') == 'expose':")
    H.append("            ui = st['node']['ui_type']")
    H.append("            p  = st.get('port','')")
    H.append("            if ui == 'Group Input' and p:")
    H.append("                exp_gi.append((p, _guess_socket_type(p)))")
    H.append("            if ui == 'Group Output' and p:")
    H.append("                exp_go.append((p, _guess_socket_type(p)))")
    H.append("    inf_gi, inf_go = _infer_interface_ports_from_graph(ng, idmap, top_ir['steps'])")

    H.append("    have = set(n for n,_ in gi_ports)")
    H.append("    for n,t in inf_gi:")
    H.append("        if n not in have: gi_ports.append((n,t)); have.add(n)")
    H.append("    have = set(n for n,_ in go_ports)")
    H.append("    for n,t in inf_go:")
    H.append("        if n not in have: go_ports.append((n,t)); have.add(n)")
    H.append("    print(f\"[DEBUG] Rebuilding interface: gi_ports={gi_ports}, go_ports={go_ports}\")")
    H.append("    rebuild_interface(ng, gi_ports, go_ports)")
    H.append("    ng.interface_update(bpy.context)  # Ensure interface is refreshed after rebuild")
    H.append("    _apply_pending_gi_defaults(ng)")
    H.append("    if tree_type == 'GEOMETRY':")
    H.append("        _mirror_gi_defaults_to_modifier(mod, ng)")
    H.append("    # (deferred) build interface AFTER pre-applying type-affecting settings")
    H.append("    gi_ports = []; go_ports = []")

    H.append("    # pre-apply Data Type for nodes whose socket types depend on it")
    H.append("    for st in top_ir['steps']:")
    H.append("        if st.get('kind') != 'set':")
    H.append("            continue")
    H.append("        ui = st['node']['ui_type']")
    H.append("        if ui not in ('Index Switch', 'Random Value'):")
    H.append("            continue")
    H.append("        n = idmap.get((ui, st['node']['inst'] or ''))")
    H.append("        if not n:")
    H.append("            continue")
    H.append("        for kv in st['entries']:")
    H.append("            if str(kv['key']).strip() == 'Data Type':")
    H.append("                _apply_kv(n, kv['key'], kv['val'])")

    H.append("    # dynamic adjustments (e.g., Index Switch cases) before any other sets/links")
    H.append("    for st in top_ir['steps']:")
    H.append("        if st.get('kind') == 'adjust_cases':")
    H.append("            n = idmap.get((st['node']['ui_type'], st['node']['inst'] or ''))")
    H.append("            if n: _set_index_switch_cases(n, st['count'])")
    H.append("    # inferred case counts from Declare lines (if exporter didn‚Äôt emit adjust_cases)")
    H.append("    req = _infer_index_switch_counts(top_ir['steps'])")
    H.append("    for key, cnt in req.items():")
    H.append("        n = idmap.get(key);  _set_index_switch_cases(n, cnt) if n else None")
    H.append("    # pair zones (Simulation/Repeat) at top level before any sets/links")
    H.append("    for st in top_ir['steps']:")
    H.append("        if st.get('kind') != 'pairzone': continue")
    H.append("        L = idmap.get((st['left']['ui_type'],  st['left']['inst']  or ''))")
    H.append("        R = idmap.get((st['right']['ui_type'], st['right']['inst'] or ''))")
    H.append("        if not L or not R: continue")
    H.append("        paired = False")
    H.append("        f = getattr(L, 'pair_with_output', None)")
    H.append("        if callable(f):")
    H.append("            try: f(R); paired = True")
    H.append("            except Exception: pass")
    H.append("        if not paired:")
    H.append("            g = getattr(R, 'pair_with_input', None)")
    H.append("            if callable(g):")
    H.append("                try: g(L); paired = True")
    H.append("                except Exception: pass")
    H.append("        if not paired:")
    H.append("            _warn(f\"Failed to pair zone {getattr(L,'name','?')} <-> {getattr(R,'name','?')}\")")

    H.append("    # sets (after structure adjusted)")

# --- TOP-LEVEL GI defaults block: SetUser overrides or fall back to Set ---
    # --- BEGIN DROP-IN REPLACEMENT ---
    H.append("    # --- Group Input interface defaults (TOP LEVEL) with SetUser overrides ---")
    H.append("    user = {}")
    H.append("    # Collect user overrides first (by plain socket name / meta)")
    H.append("    for st in top_ir['steps']:")
    H.append("        if st.get('kind') == 'set_user' and st['node']['ui_type'] == 'Group Input':")
    H.append("            for kv in st['entries']:")
    H.append("                k = _normalize_gi_key(kv['key'])")
    H.append("                user[k] = kv['val']")
    H.append("")
    H.append("    # Queue defaults exactly as exported")
    H.append("    for st in top_ir['steps']:")
    H.append("        if st.get('kind') != 'set':")
    H.append("            continue")
    H.append("        if st['node']['ui_type'] != 'Group Input':")
    H.append("            continue")
    H.append("        for kv in st['entries']:")
    H.append("            k = _normalize_gi_key(kv['key'])")
    H.append("            _queue_gi_default(ng, k, kv['val'])")
    H.append("")
    H.append("    # Queue overrides (modifier values) separately")
    H.append("    for k, raw in user.items():")
    H.append("        _queue_gi_override(ng, k, raw)")
    H.append("")
    H.append("    # Apply the just-queued top-level GI defaults now, then mirror to the modifier UI")
    H.append("    _apply_pending_gi_defaults(ng)")
    H.append("    if tree_type == 'GEOMETRY':")
    H.append("        _mirror_gi_defaults_to_modifier(mod, ng)")

    H.append("")
    # --- END DROP-IN REPLACEMENT ---


    H.append("    # Apply non-Group Input Set entries")
    # Collect frame locations for deferred setting (after parenting)
    H.append("    frame_locations = {}  # (ui_type, inst) -> location_value")
    H.append("    for st in top_ir['steps']:")
    H.append("        if st.get('kind') != 'set':")
    H.append("            continue")
    H.append("        ui = st['node']['ui_type']")
    H.append("        if ui == 'Group Input':")
    H.append("            continue")
    H.append("        inst = st['node']['inst'] or ''")
    H.append("        n = idmap.get((ui, inst))")
    H.append("        print(f\"[DEBUG] Processing Set for ui={ui}, inst={inst}, n={getattr(n,'name',type(n).__name__) if n else None}\")")
    H.append("        if not n:")
    H.append("            continue")
    H.append("        is_frame = (getattr(n, 'bl_idname', '') == 'NodeFrame' or getattr(n, 'type', '') == 'FRAME')")
    H.append("        for kv in st['entries']:")
    H.append("            # Defer frame locations until after parenting")
    H.append("            if is_frame and kv['key'] == 'location':")
    H.append("                frame_locations[(ui, inst)] = kv['val']")
    H.append("                print(f\"[DEBUG] Deferred frame location: {kv['val']}\")")
    H.append("                continue")
    H.append("            print(f\"[DEBUG] Set entry: key='{kv['key']}', val={kv['val']}\")")
    H.append("            _apply_kv(n, kv['key'], kv['val'])")

    H.append("    # links")
    H.append("    for st in top_ir['steps']:")
    H.append("        if st['kind'] != 'connect': continue")
    H.append("        try:")
    H.append("            print(f\"[DEBUG] Processing Connect: {st}\")")
    H.append("            dst = idmap.get((st['to']['ui_type'], st['to']['inst'] or ''))")
    H.append("            if not dst: _warn(f\"Target missing: {st['to']}\"); continue")
    H.append("            if st.get('from_field'):_warn(f\"Skipping dotted field literal '{st['from_field']}'\"); continue")
    H.append("            src = idmap.get((st['from']['ui_type'], st['from']['inst'] or '')) if st.get('from') else None")
    H.append("            if not src: _warn(f\"Source missing: {st.get('from')}\"); continue")
    H.append("            sa = resolve_socket_by_display(src, 'out', st['from_port'])")
    H.append("            sb = resolve_socket_by_display(dst, 'in',  st['to_port'])")
    H.append("            # CRITICAL FIX: Mix node socket type refinement for TOP-LEVEL connections")
    H.append("            print(f\"[CONNECT-MIX-FIX-v1] Before refinement: src={getattr(src,'name','?')}, dst={getattr(dst,'name','?')}, sa={sa}, sb={sb}\")")
    H.append("            # Refine SOURCE output socket if from Mix node")
    H.append("            if sa is not None and hasattr(src, 'data_type'):")
    H.append("                try:")
    H.append("                    dtype = getattr(src, 'data_type', None)")
    H.append("                    port_name = str(st['from_port']).strip()")
    H.append("                    if dtype and port_name in ('Result',):")
    H.append("                        sock_list = [s for s in getattr(src, 'outputs', []) if getattr(s, 'name', '') == port_name]")
    H.append("                        if len(sock_list) > 1:")
    H.append("                            type_map = {'RGBA': 'Color', 'FLOAT': 'Float', 'VECTOR': 'Vector', 'ROTATION': 'Rotation'}")
    H.append("                            wanted = type_map.get(dtype, 'Float')")
    H.append("                            for s in sock_list:")
    H.append("                                if wanted in (getattr(s, 'bl_idname', '') or type(s).__name__):")
    H.append("                                    sa = s")
    H.append("                                    print(f\"[CONNECT-MIX-FIX-v1] Refined SOURCE to {wanted}: {sa}\")")
    H.append("                                    break")
    H.append("                except Exception as ex:")
    H.append("                    print(f\"[CONNECT-MIX-FIX-v1] Source refinement failed: {ex}\")")
    H.append("            # Refine DESTINATION input socket if to Mix node")
    H.append("            if sb is not None and hasattr(dst, 'data_type'):")
    H.append("                try:")
    H.append("                    dtype = getattr(dst, 'data_type', None)")
    H.append("                    port_name = str(st['to_port']).strip()")
    H.append("                    if dtype and port_name in ('A', 'B', 'Factor', 'Result'):")
    H.append("                        sock_list = [s for s in getattr(dst, 'inputs', []) if getattr(s, 'name', '') == port_name]")
    H.append("                        if len(sock_list) > 1:")
    H.append("                            type_map = {'RGBA': 'Color', 'FLOAT': 'Float', 'VECTOR': 'Vector', 'ROTATION': 'Rotation'}")
    H.append("                            wanted = type_map.get(dtype, 'Float')")
    H.append("                            for s in sock_list:")
    H.append("                                if wanted in (getattr(s, 'bl_idname', '') or type(s).__name__):")
    H.append("                                    sb = s")
    H.append("                                    print(f\"[CONNECT-MIX-FIX-v1] Refined DEST to {wanted}: {sb}\")")
    H.append("                                    break")
    H.append("                except Exception as ex:")
    H.append("                    print(f\"[CONNECT-MIX-FIX-v1] Refinement failed: {ex}\")")
    H.append("            print(f\"[DEBUG] Linking {getattr(src,'name','?')}['{st['from_port']}'] -> {getattr(dst,'name','?')}['{st['to_port']}']\")")
    H.append("            print(f\"[DEBUG] Resolved sockets: sa={sa}, sb={sb}\")")
    H.append("            if sa is None or sb is None:")
    H.append("                _warn(f\"Skip link {src.name}.{st['from_port']} -> {dst.name}.{st['to_port']} (unresolved socket)\")")
    H.append("            else:")
    H.append("                if not _new_link_with_convert(nt, sa, sb):")
    H.append("                    _warn(f\"Skip link {src.name}.{st['from_port']} -> {dst.name}.{st['to_port']} (link failed)\")")
    H.append("        except Exception as e:")
    H.append("            print(f\"[DEBUG] Link Exception: {e}\")")
    H.append("            import traceback; traceback.print_exc()")

    # Apply node label renames (including frames)
    H.append("    for st in top_ir['steps']:")
    H.append("        if st.get('kind') != 'rename_node': continue")
    H.append("        n = idmap.get((st['node']['ui_type'], st['node']['inst'] or ''))")
    H.append("        if not n: continue")
    H.append("        try:")
    H.append("            n.label = st['label']")
    H.append("        except Exception:")
    H.append("            pass")
    H.append("")

    # Apply frame parenting
    H.append("    for st in top_ir['steps']:")
    H.append("        if st.get('kind') != 'parent': continue")
    H.append("        child = idmap.get((st['child']['ui_type'], st['child']['inst']))")
    H.append("        parent = idmap.get((st['parent']['ui_type'], st['parent']['inst']))")
    H.append("        if child and parent:")
    H.append("            child.parent = parent")
    H.append("")
    
    # Apply frame locations (after parenting to handle relative positioning)
    # Sort frames by depth (parents first) to ensure parent locations are set before calculating child offsets
    H.append("    def _get_parent_depth(node):")
    H.append("        depth = 0")
    H.append("        current = node")
    H.append("        while hasattr(current, 'parent') and current.parent:")
    H.append("            depth += 1")
    H.append("            current = current.parent")
    H.append("        return depth")
    H.append("    sorted_frames = sorted(frame_locations.items(), key=lambda item: _get_parent_depth(idmap.get(item[0], None)) if idmap.get(item[0]) else 999)")
    H.append("    print(f'[DEBUG] Applying {len(sorted_frames)} frame locations in depth order')")
    H.append("    for (ui, inst), loc_val in sorted_frames:")
    H.append("        n = idmap.get((ui, inst))")
    H.append("        if not n: continue")
    H.append("        depth = _get_parent_depth(n)")
    H.append("        px, py = _parse_value(loc_val) if isinstance(_parse_value(loc_val), (tuple,list)) else (0, 0)")
    H.append("        parent_name = getattr(n.parent, 'name', 'None') if hasattr(n, 'parent') and n.parent else 'None'")
    H.append("        print(f'[DEBUG-FRAME] {n.name} (depth={depth}, parent={parent_name}): absolute=({px}, {py})')")

    H.append("        n.location = (px, py)")
    H.append("        print(f'[DEBUG-FRAME]   SET n.location = ({px}, {py})')")
    H.append("")

    # FINAL PASS: Force root frames to absolute positions (fixes Blender auto-repositioning)
    H.append("    print(f'[DEBUG] Final pass: correcting root frame positions...')")
    H.append("    for (ui, inst), loc_val in frame_locations.items():")
    H.append("        n = idmap.get((ui, inst))")
    H.append("        if not n: continue")
    H.append("        # Only adjust root frames (no parent)")
    H.append("        if not hasattr(n, 'parent') or not n.parent:")
    H.append("            px, py = _parse_value(loc_val) if isinstance(_parse_value(loc_val), (tuple,list)) else (0, 0)")
    H.append("            print(f'[DEBUG-FRAME-FINAL] ROOT {n.name}: forcing to ({px}, {py})')")
    H.append("            n.location = (px, py)")
    H.append("")

    H.append("    #_layout_minimal(nt) #disabled -")
    H.append("    _info('Top-level build complete.')")
    H.append("    return nt")
    H.append("")
    H.append("def run_from_ir(ir_json):")
    H.append("    data = json.loads(ir_json)")
    H.append("    tree_type = data.get('tree_type', 'GEOMETRY')")
    H.append("    tree_name = data.get('tree_name', 'BNDL_Tree')")
    H.append("    return build_top_on_active_object(data['top'], data['groups'], tree_type, tree_name)")
    return H

# --------------------------
# Codegen
# --------------------------
def generate_script(bndl_text: str) -> str:
    # Parse and build an IR blob (JSON) then embed it into the replay script
    doc = parse_bndl(bndl_text)
    
    # Parse tree type and tree name from header
    tree_type = parse_tree_type_header(bndl_text)
    if tree_type is None:
        tree_type = 'GEOMETRY'  # Default fallback
    
    # Extract node tree name from header (for proper naming)
    from .bndl_common import parse_node_tree_name_header
    tree_name = parse_node_tree_name_header(bndl_text) or 'BNDL_Tree'


    def node_to_dict(n: NodeRef) -> dict:
        return {"ui_type": n.ui_type, "label": n.label, "inst": n.inst, "bl_idname": n.bl_idname}

    def step_to_dict(st) -> dict:
        # Pass through pre-normalized dict steps (e.g., rename_input / rename_node / adjust_cases)
        if isinstance(st, dict):
            return st

        if isinstance(st, CreateStmt):
            return {"kind": "create", "node": node_to_dict(st.node), "variant": st.variant}
        if isinstance(st, DeclareStmt):
            return {"kind": "declare", "side": st.side, "node": node_to_dict(st.node), "ports": st.ports}
        if isinstance(st, SetStmt):
            return {"kind": "set", "node": node_to_dict(st.node), "entries": [{"key": e.key, "val": e.val} for e in st.entries]}
        if isinstance(st, ConnectStmt):
            d = {"kind": "connect", "dotted": st.dotted, "to": node_to_dict(st.to_node), "to_port": st.to_port}
            if st.from_field: d["from_field"] = st.from_field
            if st.from_node:  d["from"] = node_to_dict(st.from_node); d["from_port"] = st.from_port
            return d
        if isinstance(st, PairZoneStmt):
            return {"kind": "pairzone", "zone": st.kind, "left": node_to_dict(st.left), "right": node_to_dict(st.right)}
        return {"kind": "unknown"}


    # Groups IR
    groups_ir = []
    for g in doc.groups:
        groups_ir.append({
            "name": g.name,
            "steps": [step_to_dict(s) for s in g.steps]
        })

    top = {"steps":[step_to_dict(s) for s in doc.top_steps]}
    ir_json = json.dumps({"groups":groups_ir,"top":top,"tree_type":str(tree_type),"tree_name":tree_name}, ensure_ascii=False)

    # Build script text without triple quotes
    lines = []
    lines.extend(_header_lines())
    lines.append("")
    lines.append("IR_PAYLOAD = " + repr(ir_json))
    lines.append("")
    lines.append("if __name__ == '__main__':")
    lines.append("    import bpy")
    lines.append("    data = json.loads(IR_PAYLOAD)")
    lines.append("    tree_type = data.get('tree_type', 'GEOMETRY')")
    lines.append("    tree_name = data.get('tree_name', 'BNDL_Tree')")
    lines.append("    ")
    lines.append("    # Get target objects")
    lines.append("    target_objects = globals().get('BNDL_TARGET_OBJECTS', [bpy.context.active_object])")
    lines.append("    create_as_new = globals().get('BNDL_CREATE_AS_NEW', False)")
    lines.append("    ")
    lines.append("    if not target_objects:")
    lines.append("        _warn('No target objects found - using active object')")
    lines.append("        target_objects = [bpy.context.active_object] if bpy.context.active_object else []")
    lines.append("    ")
    lines.append("    if not target_objects:")
    lines.append("        _warn('No objects to apply material to')")
    lines.append("    else:")
    lines.append("        # Build material on first object")
    lines.append("        first_obj = target_objects[0]")
    lines.append("        ")
    lines.append("        # Make first object active for build_top_on_active_object")
    lines.append("        old_active = bpy.context.view_layer.objects.active")
    lines.append("        bpy.context.view_layer.objects.active = first_obj")
    lines.append("        ")
    lines.append("        # Build the material node tree (returns node_tree, creates material on active object)")
    lines.append("        node_tree = build_top_on_active_object(data['top'], data['groups'], tree_type, tree_name)")
    lines.append("        ")
    lines.append("        # Restore old active")
    lines.append("        bpy.context.view_layer.objects.active = old_active")
    lines.append("        ")
    lines.append("        if node_tree:")
    lines.append("            _info('Material replay complete - node tree built')")
    lines.append("            ")
    lines.append("            # Get the material from the first object")
    lines.append("            base_material = None")
    lines.append("            if first_obj.data and hasattr(first_obj.data, 'materials') and len(first_obj.data.materials) > 0:")
    lines.append("                base_material = first_obj.data.materials[0]")
    lines.append("            ")
    lines.append("            if base_material:")
    lines.append("                # Apply to remaining objects")
    lines.append("                for i, obj in enumerate(target_objects):")
    lines.append("                    if not obj or not hasattr(obj.data, 'materials'):")
    lines.append("                        continue")
    lines.append("                    ")
    lines.append("                    # First object already has the material, skip it")
    lines.append("                    if i == 0:")
    lines.append("                        _info(f'{obj.name} already has base material')")
    lines.append("                        continue")
    lines.append("                    ")
    lines.append("                    # Determine which material to use")
    lines.append("                    if create_as_new:")
    lines.append("                        # Create a unique copy for this object")
    lines.append("                        material_copy = base_material.copy()")
    lines.append("                        _info(f'Created unique material copy: {material_copy.name} for {obj.name}')")
    lines.append("                    else:")
    lines.append("                        # Share the same material")
    lines.append("                        material_copy = base_material")
    lines.append("                    ")
    lines.append("                    # Apply material to object")
    lines.append("                    if len(obj.data.materials) > 0:")
    lines.append("                        obj.data.materials[0] = material_copy")
    lines.append("                        _info(f'Replaced material slot 0 on {obj.name}')")
    lines.append("                    else:")
    lines.append("                        obj.data.materials.append(material_copy)")
    lines.append("                        _info(f'Added material to {obj.name}')")
    lines.append("                ")
    lines.append("                applied_count = len([o for o in target_objects[1:] if o])")
    lines.append("                _info(f'Applied material to {applied_count + 1} object(s) total')")
    lines.append("            else:")
    lines.append("                _warn('Could not get material from first object')")
    lines.append("        else:")
    lines.append("            _warn('Material replay failed')")
    return "\n".join(lines)

# --------------------------
# Blender Text helpers + main
# --------------------------
def _read_text_block_named(name: str):
    try:
        import bpy  # noqa
        T = bpy.data.texts.get(name)
        if not T: return None
        try: return T.as_string()
        except Exception: return "".join((ln.body + "\n") for ln in T.lines)
    except Exception:
        return None

def _has_bndl_header(text: str) -> bool:
    """Return True if the BNDL header appears before any non-comment content."""
    for raw in text.splitlines():
        stripped = raw.strip()
        if not stripped:
            continue
        if stripped.startswith("# BNDL"):
            return True
        if stripped.startswith("#") or stripped.startswith(";"):
            continue
        break
    return False


def main(argv):
    # CLI path if a file is provided
    if len(argv) >= 2 and os.path.isfile(argv[1]):
        with open(argv[1], 'r', encoding='utf-8') as f:
            src = f.read()
        out = generate_script(src)
        if len(argv) >= 3:
            with open(argv[2], 'w', encoding='utf-8') as f:
                f.write(out)
        else:
            sys.stdout.write(out)
        return 0

    # Blender Text Editor path
    in_blender = False
    try:
        import bpy  # noqa
        in_blender = True
    except Exception:
        in_blender = False

    if not in_blender:
        sys.stderr.write('Usage: bndl2py.py <input.bndl> [output.py]\n')
        return 2

    src = _read_text_block_named("BNDL_Export")
    if not src:
        sys.stderr.write("[bndl2py] No Text named 'BNDL_Export' found.\n")
        return 2
    if not _has_bndl_header(src):
        sys.stderr.write("[bndl2py] 'BNDL_Export' does not look like a BNDL (missing '# BNDL' header before content).\n")
        return 2

    replay = generate_script(src)

    import bpy
    existing = {T.name for T in bpy.data.texts}
    base = "BNDL_Replay.py"
    name = base
    idx = 2
    while name in existing:
        name = f"BNDL_Replay_{idx}.py"; idx += 1
    out_txt = bpy.data.texts.new(name)
    out_txt.write(replay)
    if getattr(bpy.context, "space_data", None) is not None:
        bpy.context.space_data.text = out_txt
    print(f"[bndl2py] Wrote replay to new Text: {name}")
    return 0

if __name__ == '__main__':
    try:
        main(sys.argv)
        # do NOT sys.exit in Blender
    except Exception as e:
        sys.stderr.write(f"[bndl2py] Uncaught error: {e}\n")
        raise
